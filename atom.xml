<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>桑桑和阿战</title>
  <icon>https://www.gravatar.com/avatar/3f8ee0db2855a2f9c9e0d4db10309c61</icon>
  <subtitle>桑桑和阿战</subtitle>
  <link href="http://sang63.github.io/atom.xml" rel="self"/>
  
  <link href="http://sang63.github.io/"/>
  <updated>2022-04-22T11:49:59.689Z</updated>
  <id>http://sang63.github.io/</id>
  
  <author>
    <name>桑落</name>
    <email>2780287233@qq.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>VueRouter路由使用</title>
    <link href="http://sang63.github.io/2022/04/22/VueRouter%E8%B7%AF%E7%94%B1%E4%BD%BF%E7%94%A8/"/>
    <id>http://sang63.github.io/2022/04/22/VueRouter%E8%B7%AF%E7%94%B1%E4%BD%BF%E7%94%A8/</id>
    <published>2022-04-22T11:39:30.000Z</published>
    <updated>2022-04-22T11:49:59.689Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-认识前端路由"><a href="#1-认识前端路由" class="headerlink" title="1.认识前端路由"></a>1.认识前端路由</h3><p>  路由器主要维护的是一个映射表，每个ip地址对应一个计算器的mac地址</p><p>  前端映射关系：路径-&gt;组件（例如：&#x2F;home-&gt;Home.vue）</p><p>  （1）后端路由阶段：服务器直接生产渲染好对应的HTML页面，返回给客户端进行展示；</p><p>  （2）前后端分离阶段：后端提供API，在前端对这些请求回来的资源进行渲染；</p><p>  （3）S（Single）P（Page）A（Application）开发：组件化开发。</p><p>  history六种模式改变URL而不刷新页面：</p><p>​    replaceState：替换原来的路径</p><p>​    pushState：使用新的路径</p><p>​    popState：路径的回退</p><p>​    go：向前或向后改变路径</p><p>​    forward：向前改变路径</p><p>​    back：向后改变路径</p><h3 id="2-认识vue-router"><a href="#2-认识vue-router" class="headerlink" title="2.认识vue-router"></a>2.认识vue-router</h3><p>  目前前端流行的三大框架，都有自己的路由实现：</p><p>​    Angular的ngRouter；</p><p>​    React的ReactRouter；</p><p>  Vue的vue-router。-》官方路由。路由用于设定访问路径，将路径和组件映射起来；在vue-router的单页面中，页面的路径的变化就是组件的切换。      </p><pre><code>安装Vue Router：npm install router</code></pre><h3 id="3-路由的使用步骤"><a href="#3-路由的使用步骤" class="headerlink" title="3.路由的使用步骤"></a>3.路由的使用步骤</h3><p>  (1)创建路由组件的组件；</p><p>  (2)配置路由映射：组件与路径映射的routes关系；</p><p>  (3)通过createRouter创建路由对象，并且传入hash和history模式</p><p>  (4)使用路由：通过<code>&lt;router-link&gt;&lt;/router-link&gt;</code>和<code>&lt;router-view&gt;&lt;/router-view&gt;</code></p><p> 在routes中配置了一个映射：</p><p>   redirect重定向到&#x2F;home路径下，对默认页面进行渲染，path配置的是根路径：</p><pre><code> / ：  &#123;path:&#39;/&#39;,redirect:&#39;/home&#39;&#125;</code></pre><h3 id="4-路由懒加载-需要时再加载"><a href="#4-路由懒加载-需要时再加载" class="headerlink" title="4.路由懒加载(需要时再加载)"></a>4.路由懒加载(需要时再加载)</h3><p>  这里使用之前提到过的webpack分包知识，而Vue Router默认就支持动态来导入组件：</p><p>​    这是因为component可以传入一个组件，也可以接受一个函数，该函数需要放回一个Promise；</p><p>​    而inport函数就是返回一个Promise。</p><pre><code> 例如：const routes = [​      &#123;path:&#39;/home&#39;,component:()=&gt;import(&#39;../pages/Home.vue)&#125;​      &#123;path:&#39;/abour&#39;,component:()=&gt;import(&#39;../pages/About.vue)&#125;​    ] </code></pre><h3 id="5-路由的其他属性"><a href="#5-路由的其他属性" class="headerlink" title="5.路由的其他属性"></a>5.路由的其他属性</h3><p>  name,meta</p><h3 id="6-路由的嵌套"><a href="#6-路由的嵌套" class="headerlink" title="6.路由的嵌套"></a>6.路由的嵌套</h3><p>  什么是路由的嵌套呢？</p><p>​    目前我们匹配的Home，About，User等都属于底层路由，我们在他们之间可以来回进行切换；但是在Home页面本身，也可能会在多个组件之间来回切换：</p><p>​      比如Home中包括Product，Message，它们可以在Home内部来回切换。</p><p>​    这个时候我们就需要使用嵌套路由，在Home中也使用router-view来占位之后需要渲染的组件。</p><pre><code> &#123;​        path:&#39;/home&#39;,​        component:()=&gt;import(&#39;../pages/Home.vue),​        children:[​          &#123;​            path:&#39;&#39;,​            redirect:&#39;/home/product&#39;      //重定向文件​          &#125;,​          &#123;​            path:&#39;product&#39;,​            component:()=&gt;import(&#39;../pages/HomeProduct.vue)&#39;​          &#125;,​          &#123;​            path:&#39;message&#39;,​            component:()=&gt;import(&#39;../pages/HomeMessage.vue)&#39;​          &#125;​        ]​      &#125; </code></pre><p>7.路由的内置组件</p><p>  （1）router-link</p><p>​    常见属性：to，replace，active-class，tag（4.0以前有，决定渲染元素）</p><p>​    router-link中的v-slot（4.0后，取代tag),可以显示多个元素，更加灵活。</p><p>​      <u><!-- props:href 跳转的链接 --></u></p><p>​      <u><!-- props:route 对象 --></u></p><p>​      <u><!-- props:navigate 导航函数 --></u></p><p>​      <u><!-- props:isActive 是否当前处于活跃状态 --></u></p><p>​      a. to属性：是一个字符串，或者一个对象</p><p>​      b. replace属性：设置该属性，当点击时，会调用route.replace（），而不是route.push（）</p><p>​      c. active-class属性：设置激活a元素后应用的calss，默认是route-link-active</p><p>​      d. exact-active-class属性：链接精准激活时，应用于渲染<a>的class，默认是route-link-exact-active      </p><p>  （2）router-view（占位）</p><p>​    router-view的v-slot：</p><p>​      Component：要渲染的组件</p><p>​      route：解析出的标准化路由对象</p><h3 id="8-动态添加路由"><a href="#8-动态添加路由" class="headerlink" title="8.动态添加路由"></a>8.动态添加路由</h3><pre><code>const routes=[]  const router=createRouter(&#123;routes&#125;)  if（管理员）&#123;    //判断权限或用户添加不同的路由​    router.addRoute(&#123;path:&quot;/order&quot;,component:()=&gt;import()&#125;)  //动态添加  &#125;  if()&#123;&#125;...  app.use(router;)</code></pre><h3 id="9-动态删除路由"><a href="#9-动态删除路由" class="headerlink" title="9.动态删除路由"></a>9.动态删除路由</h3><p>  方式一：添加一个name相同的路由；</p><p>  方式二：通过removeRoute方法，传入路由名称； </p><p>​    <code>router.removeRoute（‘路由名称’）</code></p><p>  方式三：通过addRoute方法的返回值回调。    </p><pre><code>const removeRoute=router.addRouter(routeRecord)removeEoute() //删除路由如果存在的话</code></pre><h3 id="10-路由的其他方法补充："><a href="#10-路由的其他方法补充：" class="headerlink" title="10.路由的其他方法补充："></a>10.路由的其他方法补充：</h3><p>  router.hasRoute（）。检查路由是否存在</p><p>  router.getRoutes（）。获取一个包含所有路由记录的数组</p><h3 id="11-路由导航守卫"><a href="#11-路由导航守卫" class="headerlink" title="11.路由导航守卫"></a>11.路由导航守卫</h3><p>  vue-router提供的导航守卫主要用来通过跳转或取消的方式守卫导航</p><p>  全局的前置守卫beforeEach是在导航出发时会被回调的。有两个参数：to和from</p>  <!-- 导航守卫 --><p>  let counter&#x3D;0;</p>  <!-- to:Route对象，即将跳转到Route对象 -->  <!-- from:Route对象，从哪一个路由对象导航过来的 -->  <!-- 返回值问题：​    1.false：不进行导航​    2.undefind或者不写返回值：进行默认导航​    3.字符串：路径，跳转到对应的路径中​    4.对象：类似于router.push({path:"",query:....}) --><pre><code>router.beforeEach((to,from)=&gt;&#123;​    console.log(`进行了$&#123;++counter&#125;次路由跳转`);​    return false  &#125;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-认识前端路由&quot;&gt;&lt;a href=&quot;#1-认识前端路由&quot; class=&quot;headerlink&quot; title=&quot;1.认识前端路由&quot;&gt;&lt;/a&gt;1.认识前端路由&lt;/h3&gt;&lt;p&gt;  路由器主要维护的是一个映射表，每个ip地址对应一个计算器的mac地址&lt;/p&gt;
&lt;p&gt;  </summary>
      
    
    
    
    
    <category term="Vue3" scheme="http://sang63.github.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue脚手架报错 Component name “Student“ should always be multi-word...</title>
    <link href="http://sang63.github.io/2022/04/21/Vue%E8%84%9A%E6%89%8B%E6%9E%B6%E6%8A%A5%E9%94%99-Component-name-%E2%80%9CStudent%E2%80%9C-should-always-be-multi-word-vue-multi-word-component-names/"/>
    <id>http://sang63.github.io/2022/04/21/Vue%E8%84%9A%E6%89%8B%E6%9E%B6%E6%8A%A5%E9%94%99-Component-name-%E2%80%9CStudent%E2%80%9C-should-always-be-multi-word-vue-multi-word-component-names/</id>
    <published>2022-04-21T12:22:05.000Z</published>
    <updated>2022-04-21T12:29:22.598Z</updated>
    
    <content type="html"><![CDATA[<img src="https://img-blog.csdnimg.cn/6838240875bf4df1a12f8c3c230ed3ef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="01" style="zoom:50%;" /><h3 id="报错分析："><a href="#报错分析：" class="headerlink" title="报错分析："></a>报错分析：</h3><p>根据提示信息可知是组件名出了问题，报错信息翻译过来大概就是组件名”Student”应该总是使用 多个单词拼接横线组成的。</p><p>但是组件名也是可以使用单个单词的,只是官方文档上面的风格建议我们使用大驼峰或使用“-”衔接的方式而已。</p><p>通过后续学习了解到,这其实是<strong>语法检查的时候把不规范的代码(即命名不规范)当成了错误。</strong></p><h3 id="修改方案："><a href="#修改方案：" class="headerlink" title="修改方案："></a><strong>修改方案：</strong></h3><ul><li><strong>修改组件名，使其符合命名规范。例如：StudentName或者student-name。</strong></li><li><strong>修改配置项，关闭语法检查：</strong></li></ul><p> （1）在项目的<strong>根目录</strong>找到(没有就自行创建)<code>vue.config.js</code>文件</p><img src="https://img-blog.csdnimg.cn/5d35b9d16f91466f9f356ac1b5035a7b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_8,color_FFFFFF,t_70,g_se,x_16" alt="02" style="zoom:50%;" /><p> （2）在文件中添加如下内容</p><pre><code>const &#123; defineConfig &#125; = require(&#39;@vue/cli-service&#39;)module.exports = defineConfig(&#123;  transpileDependencies: true,  lintOnSave:false /*关闭语法检查*/&#125;)</code></pre><p> （3）随后保存文件重新编译即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;https://img-blog.csdnimg.cn/6838240875bf4df1a12f8c3c230ed3ef.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_</summary>
      
    
    
    
    
    <category term="问题解决" scheme="http://sang63.github.io/tags/%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3组件化开发(下)</title>
    <link href="http://sang63.github.io/2022/04/12/Vue3%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://sang63.github.io/2022/04/12/Vue3%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2022-04-12T02:02:14.000Z</published>
    <updated>2022-04-12T02:06:32.441Z</updated>
    
    <content type="html"><![CDATA[<h2 id="9-渲染作用域"><a href="#9-渲染作用域" class="headerlink" title="9. 渲染作用域"></a>9. 渲染作用域</h2><p>在vue中有渲染作用域的概念：</p><ul><li>父级模板里的所有内容都是在父级作用域中编译的；</li><li>子模板里的所有内容都是在子作用域中编译的。</li></ul><p>如何理解这句话呢？我们来看一个案例：</p><p>在我们的案例中ChildCpn自然是可以让访问自己作用域中的title内容的，但是在App中，是访问不了ChildCpn中的内容的，因为它们是跨作用域的访问。</p><img src="https://img-blog.csdnimg.cn/28bbf4b9519445618772d5c492ba021c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="9.1" style="zoom:67%;" /><h3 id="9-1-认识作用域插槽"><a href="#9-1-认识作用域插槽" class="headerlink" title="9.1 认识作用域插槽"></a>9.1 认识作用域插槽</h3><p>但是有时候我们希望插槽可以访问到子组件中的内容是非常重要的：</p><p>当一个组件被用来渲染一个数组元素时，我们使用插槽，并且希望插槽中没有显示每项的内容，这个Vue给我们提供了作用域插槽。</p><p><strong>我们来看下面的一个案例：</strong></p><ul><li>在App.vue中定义好数据</li><li>传递给ShowNames组件中</li><li>ShowNames组件中便利names数据</li><li>定义插槽的prop</li><li>通过v-slot:default的方式获取到slot的props</li><li>使用slotProps中的item和index</li></ul><img src="https://img-blog.csdnimg.cn/2fab9ef92c84412a8e9541ca457d432f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="9.1.1" style="zoom:50%;" /><h2 id="10-独占默认插槽的缩写"><a href="#10-独占默认插槽的缩写" class="headerlink" title="10. 独占默认插槽的缩写"></a>10. 独占默认插槽的缩写</h2><p>如果我们的插槽是默认插槽default，那么在使用的时候v-slot:default&#x3D;”slotProps”可以简写为v-slot&#x3D;“slotProps”：</p><img src="https://img-blog.csdnimg.cn/7a584b716eb1451eb2cea2ae5dd3335a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_17,color_FFFFFF,t_70,g_se,x_16" alt="10.1" style="zoom:50%;" /><p>而且如果我们的插槽只有默认插槽时，组件的标签可以被当作插槽的模板来使用，这样我们就可以将v-slot直接用在组件上：</p><img src="https://img-blog.csdnimg.cn/889017f6159441439b4fb49fdf43db09.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_17,color_FFFFFF,t_70,g_se,x_16" alt="10.2" style="zoom:50%;" /><h2 id="11-默认插槽和具名插槽混合"><a href="#11-默认插槽和具名插槽混合" class="headerlink" title="11. 默认插槽和具名插槽混合"></a>11. 默认插槽和具名插槽混合</h2><p>但是，如果我们有默认插槽和具名插槽，那么按照完整的template来编写。</p><img src="https://img-blog.csdnimg.cn/0d37c1f0ad4142c3a4dd6939a683ec94.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="11.1" style="zoom:50%;" /><p>只要出现多个插槽，轻时重为所有的插槽使用完整的基于template的语法：</p><img src="https://img-blog.csdnimg.cn/3776bcfef76343c9bc5977be8fec0f87.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_18,color_FFFFFF,t_70,g_se,x_16" alt="11.2" style="zoom:50%;" /><h2 id="12-切换组件案例"><a href="#12-切换组件案例" class="headerlink" title="12.切换组件案例"></a>12.切换组件案例</h2><p>比如我们现在要实现一个功能：<br> 点击一个tab-bar，切换不同的组件显示；</p><img src="https://img-blog.csdnimg.cn/d8d129c51911468c8ac5e6c77507d4cb.png" alt="12.1" style="zoom:67%;" /><p>这个案例我们可以通过两种不同的实现思路来实现：</p><ul><li>方式一：通过v-if来判断，显示不同的组件；</li><li>方式二：动态组件的方式。</li></ul><h2 id="13-v-if显示不同的组件"><a href="#13-v-if显示不同的组件" class="headerlink" title="13. v-if显示不同的组件"></a>13. v-if显示不同的组件</h2><p>我们可以通过v-if来判断显示不同的组件，这个可以使用我们之前学过的知识来实现：</p><img src="https://img-blog.csdnimg.cn/2d553b5031f34a63a4917f51fcaa1ccf.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_15,color_FFFFFF,t_70,g_se,x_16" alt="13.1" style="zoom:67%;" /><h2 id="14-动态组件"><a href="#14-动态组件" class="headerlink" title="14.动态组件"></a>14.动态组件</h2><h3 id="14-1-动态组件的实现"><a href="#14-1-动态组件的实现" class="headerlink" title="14.1 动态组件的实现"></a>14.1 动态组件的实现</h3><p>动态组件是<strong>使用computed组件</strong>，通过一个特殊的attribute is来实现：</p><img src="https://img-blog.csdnimg.cn/64f260ada0ee4d729ba1ea8e776fac0e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_15,color_FFFFFF,t_70,g_se,x_16" alt="14.1.1" style="zoom:67%;" /><p> 这个currentTab的值需要是什么内容呢？</p><ul><li>可以通过component函数注册的组件；</li><li>在一个组件对象的components对象中注册的组件。</li></ul><h3 id="14-2-动态组件的传值"><a href="#14-2-动态组件的传值" class="headerlink" title="14.2 动态组件的传值"></a>14.2 动态组件的传值</h3><p>如果是动态组件我们可以给他们<strong>传值和监听事件</strong>吗？</p><p>也是一样的，只是我们需要将属性和监听事件放到component上使用。</p><img src="https://img-blog.csdnimg.cn/1e11fffffa5f45fdbabda9b48efb2b28.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_11,color_FFFFFF,t_70,g_se,x_16" alt="14.2.1" style="zoom:67%;" /><h2 id="15-keep-alive"><a href="#15-keep-alive" class="headerlink" title="15. keep-alive"></a>15. keep-alive</h2><p>我们可以先对之前的案例中的About组件进行改造：在其中增加了一个按钮，点击可以递增的功能。</p><img src="https://img-blog.csdnimg.cn/d770ec651f494e0aac5039c59f11d9e0.png" alt="15.1" style="zoom:67%;" /><p> 比如，我们将counter点到10，那么在切换到home再切换回About组件界面时，状态是否可以保持呢？</p><p>答案是否定的，这是因为默认情况下，我们在切换组件后，about组件会被销毁，再次回来死会重新创建组件。</p><p>但是，在开发中某些情况我们想要继续保持组件的状态，而不是销毁掉，这个时候我们就可以使用一个<strong>内置组件：keep-alive</strong>。</p><img src="https://img-blog.csdnimg.cn/3691cc8d63eb48f9a33ea81622bc5021.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_12,color_FFFFFF,t_70,g_se,x_16" alt="15.2" style="zoom:67%;" /><h3 id="15-1-keep-alive属性"><a href="#15-1-keep-alive属性" class="headerlink" title="15.1 keep-alive属性"></a>15.1 keep-alive属性</h3><p>keep-alive有一些属性：</p><ul><li><strong>include</strong> - string | RegExp | Array。只有名称匹配的组件会被缓存；</li><li><strong>exclude</strong> - string | RegExp | Array。任何名称匹配的组件都不会被缓存；</li><li><strong>max</strong> - number | string。最多可以缓存多少组件实例，一旦达到这个数字，那么缓存组件中最近没有被访问的实例会被销毁。</li></ul><p>include和exclude prop允许组件有条件地缓存：</p><ul><li>二者都可以用逗号分隔字符串、正则表达式或一个数组来表示；</li><li>匹配首先检查组件自身的name选项。</li></ul><img src="https://img-blog.csdnimg.cn/6df1564a0a5c41938c89b0b8c606abc9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_12,color_FFFFFF,t_70,g_se,x_16" alt="15.1.1" style="zoom:67%;" /><h3 id="15-3-缓存组件的生命周期"><a href="#15-3-缓存组件的生命周期" class="headerlink" title="15.3 缓存组件的生命周期"></a>15.3 缓存组件的生命周期</h3><p>对于缓存组件来说，在进入时，我们是不会执行created或者mounted等生命周期函数的。但有时我们却是希望监听到合适重新进入到组件，何时离开组件，这个时候我们可以使用actived和deactivated这两个生命周期钩子函数来监听。</p><img src="https://img-blog.csdnimg.cn/3b191abebf2b4929885c18a528eb30cc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_13,color_FFFFFF,t_70,g_se,x_16" alt="15.3.1" style="zoom:67%;" /><h2 id="16-Webpack的代码分包"><a href="#16-Webpack的代码分包" class="headerlink" title="16. Webpack的代码分包"></a>16. Webpack的代码分包</h2><ul><li>默认分包过程：</li></ul><p> 默认情况下，在构建整个组件树的过程中，因为组件和组件之间时通过模块化直接依赖的，那么webpack在打包时就会将组件模块一起（比如一个app.js文件中）。</p><p>这个时候随着项目的不断庞大，app.js文件内容过大，会造成首屏的渲染速度变慢。</p><ul><li>打包时，代码的分包：</li></ul><p>对于一些不需要立即使用的组件，我们可以单独对他们经省察分，拆分成一些小的代码块chunk.js，这些chunk.js会在需要时从服务器加载下来，并且运行代码，显示对应的内容。</p><p>那么webpack中如何可以对代码进行分包呢？</p><img src="https://img-blog.csdnimg.cn/fa87b4b2ed814932b6f586e7daaf9cdb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="16.1" style="zoom:67%;" /><h3 id="16-1-Vue中实现异步组件"><a href="#16-1-Vue中实现异步组件" class="headerlink" title="16.1 Vue中实现异步组件"></a>16.1 Vue中实现异步组件</h3><p>如果我们的项目过大了，对于某些组件我们希望通过一部的方法来进行加载（目的是可以对其进行分包处理），那么Vue中给我们提供了一个函数：defineAsyncComponent。</p><p>defineAsyncComponent接受两种类型的参数：</p><ul><li>类型一：工厂函数，该工厂函数需要返回一个Promise对象；</li></ul><img src="https://img-blog.csdnimg.cn/6b303d4fc22e433ab0f231e42ea90856.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="16.1.1" style="zoom:50%;" /><ul><li>类型二：接受一个对象类型，对一部分函数进行配置。</li></ul><img src="https://img-blog.csdnimg.cn/fb4dc694a586429a832fe8e435d874df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="16.1.2" style="zoom:50%;" /><h3 id="16-2-异步组件和Suspense"><a href="#16-2-异步组件和Suspense" class="headerlink" title="16.2 异步组件和Suspense"></a>16.2 异步组件和Suspense</h3><blockquote><p>注意：目前Suspense显示的是一个实验性的特性，API随时可能会更改。</p></blockquote><p>Suspense是一个内置的全局组件，该组件有两个插槽：</p><ul><li>default：如果default可以显示，那么显示default的内容；</li><li>fallback：如果default不可以显示，那么显示fallback插槽的内容。</li></ul><img src="https://img-blog.csdnimg.cn/f0571649716444528a7aa994057e46a8.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_12,color_FFFFFF,t_70,g_se,x_16" alt="16.2.1" style="zoom:50%;" /><h3 id="16-3-refs的使用"><a href="#16-3-refs的使用" class="headerlink" title="16.3 $refs的使用"></a>16.3 $refs的使用</h3><p>某些情况下，我们在组件中想要直接获取到对象或者子组件实例，在Vue开发中我们是不推荐进行DOM操作的。这个时候，我们可以给元素或者组件绑定一个re的attribute属性。</p><p>组件实例有一个$refs属性：</p><p>他一个对象Object，持有注册过ref attribute的所有DOM元素和组件实例。</p><img src="https://img-blog.csdnimg.cn/8dc27fd6c2b94729b4d63997459ac674.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_14,color_FFFFFF,t_70,g_se,x_16" alt="16.3.1" style="zoom:50%;" /><h3 id="16-4-parent和-root"><a href="#16-4-parent和-root" class="headerlink" title="16.4 $parent和$root"></a>16.4 $parent和$root</h3><p>我们可以通过$parent来访问父元素，通过$root 来访问根组件。</p><p>HelloWorld.vue的实现：</p><img src="https://img-blog.csdnimg.cn/06f71fa22004401c8283575a14c23ce4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_14,color_FFFFFF,t_70,g_se,x_16" alt="16.4.1" style="zoom:50%;" /><blockquote><p> 注意：在Vue3中已经移除了$children的属性，已经不可以使用了。</p></blockquote><h2 id="17-生命周期"><a href="#17-生命周期" class="headerlink" title="17. 生命周期"></a>17. 生命周期</h2><h3 id="17-1-认识生命周期"><a href="#17-1-认识生命周期" class="headerlink" title="17.1 认识生命周期"></a>17.1 认识生命周期</h3><ul><li><strong>什么是生命周期呢？</strong> </li><li>每个组件都可能会经历从创建、挂载、更新、卸载等一系列的过程；在这个过程中的某一个阶段，用于可能会想要添加一些属于自己的代码逻辑（比如组件创建完后就请求一些服务器数据）。但是我们如何可以知道目前组件正在哪一个过程呢？Vue给我们提供了组件的生命周期函数。</li><li><strong>生命周期函数：</strong> </li><li>生命周期函数是一些钩子函数，在某个时间会被Vue源码内部进行回调；通过对生命周期函数的回调，我们可以知道目前组件正在经历什么阶段；那么我们就可以在该生命周期中编写属于自己的逻辑代码了。</li></ul><h3 id="17-2-生命周期的流程"><a href="#17-2-生命周期的流程" class="headerlink" title="17.2 生命周期的流程"></a>17.2 生命周期的流程</h3><img src="https://img-blog.csdnimg.cn/199d9d7ae72e48d8acad77bf65d129df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="17.2.1" style="zoom:50%;" /><h2 id="18-组件的v-model"><a href="#18-组件的v-model" class="headerlink" title="18. 组件的v-model"></a>18. 组件的v-model</h2><p><strong>前面我们在<strong><strong>input</strong></strong>中可以使用<strong><strong>v-model</strong></strong>来完成双向绑定：</strong> </p><p>这个时候往往会非常方便，因为v-model默认帮助我们完成了两件事；v-bind:value的数据绑定和@input的事件监听。如果我们现在<strong>封装了一个组件</strong>，其他地方在使用这个组件时，是否也可以<strong>使用v-model来同时完成这两个功能</strong>呢？ </p><p>也是可以的，vue也支持在组件上使用v-model； </p><p><strong>当我们在组件上使用的时候，等价于如下的操作：</strong> </p><p>我们会发现和input元素不同的只是属性的名称和事件触发的名称而已。</p><img src="https://img-blog.csdnimg.cn/124897caf26941808eac6c5e7589f05c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="18.1" style="zoom:50%;" /><h3 id="18-1-组件v-model的实现"><a href="#18-1-组件v-model的实现" class="headerlink" title="18.1 组件v-model的实现"></a>18.1 组件v-model的实现</h3><p><strong>那么，为了我们的MyInput组件可以正常的工作，这个组件内的 <input> 必须：</strong> </p><ul><li>将其 value attribute 绑定到一个名叫 modelValue 的 prop 上； </li><li>在其 input 事件被触发时，将新的值通过自定义的 update:modelValue 事件抛出。</li></ul><p>MyInput.vue的组件代码如下：</p><img src="https://img-blog.csdnimg.cn/3fbbe9dbf5f04a3e8bd937756acca300.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="18.1.1" style="zoom:67%;" /><h3 id="18-2-computed的实现"><a href="#18-2-computed的实现" class="headerlink" title="18.2 computed的实现"></a>18.2 computed的实现</h3><p>我们依然希望在组件内部按照双向绑定的做法去完成，应如何操作呢？我们可以使用计算属性setter和getter来完成。</p><img src="https://img-blog.csdnimg.cn/cbaf5600ba15444885f2cfd0ad463b5c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_14,color_FFFFFF,t_70,g_se,x_16" alt="18.2.1" style="zoom:50%;" /><h3 id="18-3-绑定多个属性"><a href="#18-3-绑定多个属性" class="headerlink" title="18.3 绑定多个属性"></a>18.3 绑定多个属性</h3><p>我们现在通过v-model是直接绑定了一个属性，如果我们<strong>希望绑定多个属性</strong>呢？ </p><p>也就是我们希望在一个组件上使用多个v-model是否可以实现呢？我们知道，默认情况下的v-model其实是绑定了 modelValue 属性和 @update:modelValue的事件。如果我们希望绑定更多，可以给v-model传入一个参数，那么这个参数的名称就是我们绑定属性的名称； </p><p>注意：这里我是绑定了两个属性的</p><pre><code>&lt;my-input v-model=&quot;message&quot; v-model:title=&quot;title&quot; /&gt;</code></pre><p><strong>v-model:title相当于做了两件事：</strong> </p><ul><li>绑定了title属性； </li><li>监听了 @update:title的事件；</li></ul><img src="https://img-blog.csdnimg.cn/4c367e0b90b84a47b382c48b07c89116.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_13,color_FFFFFF,t_70,g_se,x_16" alt="18.3.1" style="zoom:50%;" /><h2 id="19-认识Mixin"><a href="#19-认识Mixin" class="headerlink" title="19. 认识Mixin"></a>19. 认识Mixin</h2><p>目前我们是使用组件化的方式在开发整个Vue的应用程序，但是<strong>组件和组件之间有时候会存在相同的代码逻辑</strong>，我们希望对<strong>相同的代码逻辑进行抽取</strong>。 </p><p>在Vue2和Vue3中都支持的一种方式就是<strong>使用Mixin来完成</strong>： </p><ul><li>Mixin提供了一种非常灵活的方式，来分发Vue组件中的可复用功能； </li><li>一个Mixin对象可以包含任何组件选项； </li><li>当组件使用Mixin对象时，所有Mixin对象的选项将被 混合 进入该组件本身的选项中；</li></ul><h3 id="19-1-Mixin的基本使用"><a href="#19-1-Mixin的基本使用" class="headerlink" title="19.1 Mixin的基本使用"></a>19.1 Mixin的基本使用</h3><img src="https://img-blog.csdnimg.cn/016fb58c8f1c481a8362a5f99e2f3a10.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="19.1.1" style="zoom:50%;" /><h3 id="19-2-Mixin的合并规则"><a href="#19-2-Mixin的合并规则" class="headerlink" title="19.2 Mixin的合并规则"></a>19.2 Mixin的合并规则</h3><p><strong>如果Mixin对象中的选项和组件对象中的选项发生了冲突，那么Vue会如何操作呢？</strong> </p><p>这里分成不同的情况来进行处理； </p><ul><li><strong>情况一：如果是data函数的返回值对象</strong></li></ul><p>返回值对象默认情况下会进行合并，如果data返回值对象的属性发生了冲突，那么会保留组件自身的数据； </p><ul><li><strong>情况二：如何生命周期钩子函数</strong></li></ul><p>生命周期的钩子函数会被合并到数组中，都会被调用； </p><ul><li><strong>情况三：值为对象的选项，例如 methods、components 和 directives，将被合并为同一个对象。</strong></li></ul><p>比如都有methods选项，并且都定义了方法，那么它们都会生效。但是如果对象的key相同，那么会取组件对象的键值对。</p><h3 id="19-3-全局混入Mixin"><a href="#19-3-全局混入Mixin" class="headerlink" title="19.3 全局混入Mixin"></a>19.3 全局混入Mixin</h3><p><strong>如果组件中的某些选项，是所有的组件都需要拥有的，那么这个时候我们可以使用<strong><strong>全局的mixin</strong></strong>：</strong> </p><ul><li>全局的Mixin可以使用 应用app的方法 mixin 来完成注册； </li><li>一旦注册，那么全局混入的选项将会影响每一个组件。</li></ul><img src="https://img-blog.csdnimg.cn/0fecce4014354d008e1220d7b4f60660.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_16,color_FFFFFF,t_70,g_se,x_16" alt="19.3.1" style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;9-渲染作用域&quot;&gt;&lt;a href=&quot;#9-渲染作用域&quot; class=&quot;headerlink&quot; title=&quot;9. 渲染作用域&quot;&gt;&lt;/a&gt;9. 渲染作用域&lt;/h2&gt;&lt;p&gt;在vue中有渲染作用域的概念：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父级模板里的所有内容都是在父级作用域中</summary>
      
    
    
    
    
    <category term="vue3" scheme="http://sang63.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3组件化开发(上)</title>
    <link href="http://sang63.github.io/2022/04/02/Vue3%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/"/>
    <id>http://sang63.github.io/2022/04/02/Vue3%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91/</id>
    <published>2022-04-02T10:34:48.000Z</published>
    <updated>2022-04-12T02:06:28.683Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-认识组件的嵌套"><a href="#1-认识组件的嵌套" class="headerlink" title="1.认识组件的嵌套"></a><strong>1.认识组件的嵌套</strong></h2><p><strong>前面我们是将所有的逻辑放到一个App.vue中：</strong> </p><p>在之前的案例中，我们只是创建了一个组件App，如果我们一个应用程序将所有的逻辑都放在一个组件中，那么这个组件就会变成非常的臃肿和难以维护。</p><p>所以组件化的核心思想应该是对组件进行拆分，拆分成一个个小的组件；再将这些组件组合嵌套在一起，最终形成我们的应用程序； </p><p>我们来分析一下下面代码的嵌套逻辑，假如我们将所有的代码逻辑都放到一个App.vue组件中： </p><ul><li>我们会发现，将所有的代码逻辑全部放到一个组件中，代码是非常的臃肿和难以维护的。 </li><li>并且在真实开发中，我们会有更多的内容和代码逻辑，对于扩展性和可维护性来说都是非常差的。 </li><li>所以，在真实的开发中，我们会对组件进行拆分，拆分成一个个功能的小组件。</li></ul> <img src="https://img-blog.csdnimg.cn/1b6f14b3830c473f953b5d71c2a1e4ba.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_13,color_FFFFFF,t_70,g_se,x_16" alt="1.1" style="zoom:50%;" /><h2 id="2-组件的拆分"><a href="#2-组件的拆分" class="headerlink" title="2.组件的拆分"></a>2.组件的拆分</h2><img src="https://img-blog.csdnimg.cn/cf33bda26a424c8cae2b56e455b5c76c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="2.1" style="zoom:50%;" /><p>按照如上的拆分方式后，我们开发对应的逻辑只需要去对应的组件编写就可。</p><h2 id="3-组件的通信"><a href="#3-组件的通信" class="headerlink" title="3.组件的通信"></a>3.组件的通信</h2><p><strong>上面的嵌套逻辑如下，它们存在如下关系：</strong> </p><ul><li>App组件是Header、Main、Footer组件的父组件； </li><li>Main组件是Banner、ProductList组件的父组件；</li></ul><p>在开发过程中，我们会经常遇到需要<strong>组件之间相互进行通信</strong>： </p><ul><li>比如App可能使用了多个Header，每个地方的Header展示的内容不同，那么我们就需要使用者传递给Header一些数据，让其进行展示； </li><li>又比如我们在Main中一次性请求了Banner数据和ProductList数据，那么就需要传递给它们来进行展示； </li><li>也可能是子组件中发生了事件，需要由父组件来完成某些操作，那就需要子组件向父组件传递事件；</li></ul><p>总之，在一个Vue项目中，组件之间的通信是非常重要的环节，所以接下来我们就具体学习一下组件之间是如何相互之间传递数据的。</p><h2 id="4-父子组件之间的通信"><a href="#4-父子组件之间的通信" class="headerlink" title="4.父子组件之间的通信"></a>4.父子组件之间的通信</h2><p><strong>父子组件之间如何进行通信呢？</strong> </p><ul><li>父组件传递给子组件：通过props属性； </li><li>子组件传递给父组件：通过$emit触发事件；</li></ul><img src="https://img-blog.csdnimg.cn/bc80ad9bd8cf47f084544b83dcf8307c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="4.1" style="zoom:50%;" /><h3 id="4-1父组件传递给子组件"><a href="#4-1父组件传递给子组件" class="headerlink" title="4.1父组件传递给子组件"></a>4.1父组件传递给子组件</h3><p>在开发中很常见的就是<strong>父子组件之间通信</strong>，比如父组件有一些数据，需要子组件来进行展示，这个时候我们可以通过props来完成组件之间的通信；</p><p><strong>什么是Props呢？</strong> </p><p>Props是你可以在组件上注册一些自定义的attribute；父组件给这些attribute赋值，子组件通过attribute的名称获取到对应的值； </p><p><strong>Props有两种常见的用法：</strong> </p><ul><li>方式一：字符串数组，数组中的字符串就是attribute的名称； </li><li>方式二：对象类型，对象类型我们可以在指定attribute名称的同时，指定它需要传递的类型、是否是必须的、默认值等等；</li></ul><p>4.1.1Props的数组用法</p><img src="https://img-blog.csdnimg.cn/00242c635d1f4796a175441eb71c3824.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="4.1.1" style="zoom:40%;" /><p>4.1.2Props的对象用法</p><p>数组用法中我们<strong>只能说明传入的attribute的名称</strong>，并<strong>不能对其进行任何形式的限制</strong>，接下来我们来看一下<strong>对象的****写法</strong>是如何让我们的props变得更加完善的。 </p><p><strong>当使用对象语法的时候，我们可以对传入的内容限制更多：</strong> </p><ul><li>比如指定传入的attribute的类型； </li><li>比如指定传入的attribute是否是必传的； </li><li>比如指定没有传入时，attribute的默认值；</li></ul><img src="https://img-blog.csdnimg.cn/69f6a27ccd4746258478c6a14e07a987.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_16,color_FFFFFF,t_70,g_se,x_16" alt="4.1.2" style="zoom:50%;" /><p> 4.1.3细节</p><p>（1）<strong>细节一：那么type的类型都可以是哪些呢？</strong></p><ul><li>String </li><li>Number </li><li>Boolean </li><li>Array </li><li>Object </li><li>Date </li><li>Function </li><li>Symbol</li></ul><p>（2）<strong>细节二：对象类型的其他写法</strong></p><img src="https://img-blog.csdnimg.cn/4e2fa33cdc434cdfad5a1f590dd9bd80.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="4.1.3" style="zoom:40%;" /><p> （3）<strong>细节三：Prop 的大小写命名</strong></p><p><strong>Prop 的大小写命名(camelCase vs kebab-case)</strong> </p><p>HTML 中的 attribute 名是大小写不敏感的，所以浏览器会把所有大写字符解释为小写字符； </p><p>这意味着当你使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名。</p><img src="https://img-blog.csdnimg.cn/12879c60877b42d7973d22209b8b1b88.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="4.1.4" style="zoom:50%;" /><p>4.1.4<strong>非Prop的Attribute</strong><br><strong>什么是非Prop的Attribute呢？</strong> </p><ul><li>当我们传递给一个组件某个属性，但是该属性并没有定义对应的props或者emits时，就称之为 <strong>非Prop的</strong> <strong>Attribute</strong>； </li><li>常见的包括class、style、id属性等；</li></ul><p><strong>Attribute继承</strong> </p><ul><li>当组件有单个根节点时，非Prop的Attribute将自动添加到根节点的Attribute中：</li></ul><img src="https://img-blog.csdnimg.cn/00b3f532f2c24ae2b1a6b5f6cc652a33.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="4.1.5" style="zoom:50%;" /><p> 4.1.5<strong>禁用Attribute继承和多根节点</strong></p><p>如果我们<strong>不希望组件的根元素继承attribute</strong>，可以在组件中设置 <strong>inheritAttrs: false</strong>： </p><ul><li>禁用attribute继承的常见情况是需要将attribute应用于根元素之外的其他元素； </li><li>我们可以通过 $attrs来访问所有的 非props的attribute；</li></ul><img src="https://img-blog.csdnimg.cn/897f1cbc13ac449a9d8011601c133e37.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_19,color_FFFFFF,t_70,g_se,x_16" alt="4.1.6" style="zoom:50%;" /><p><strong>多个根节点的attribute</strong> </p><p>多个根节点的attribute如果没有显示的绑定，那么会报警告，我们必须手动的指定要绑定到哪一个属性上：</p><img src="https://img-blog.csdnimg.cn/dfa13a25a01d4d76bf82480ae2b6123e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="4.1.7" style="zoom:50%;" /><h3 id="4-2子组件传递给父组件"><a href="#4-2子组件传递给父组件" class="headerlink" title="4.2子组件传递给父组件"></a>4.2子组件传递给父组件</h3><p><strong>什么情况下子组件需要传递内容到父组件呢？</strong> </p><ul><li>当子组件有一些事件发生的时候，比如在组件中发生了点击，父组件需要切换内容； </li><li>子组件有一些内容想要传递给父组件的时候；</li></ul><p><strong>我们如何完成上面的操作呢？</strong> </p><ul><li>首先，我们需要在子组件中定义好在某些情况下触发的事件名称； </li><li>其次，在父组件中以v-on的方式传入要监听的事件名称，并且绑定到对应的方法中； </li><li>最后，在子组件中发生某个事件的时候，根据事件名称触发对应的事件；</li></ul><h2 id="5-自定义组件的流程"><a href="#5-自定义组件的流程" class="headerlink" title="5.自定义组件的流程"></a>5.自定义组件的流程</h2><p>我们封装一个CounterOperation.vue的组件： </p><p>内部其实是监听两个按钮的点击，点击之后通过 this.$emit的方式发出去事件；</p><img src="https://img-blog.csdnimg.cn/bb61284e104a4444924092104a5ea063.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="5.1" style="zoom:50%;" /><h2 id="6-自定义事件的参数和验证"><a href="#6-自定义事件的参数和验证" class="headerlink" title="6.自定义事件的参数和验证"></a>6.<strong>自定义事件的参数和验证</strong></h2><p>自定义事件的时候，我们也可以传递一些参数给父组件： </p><img src="https://img-blog.csdnimg.cn/363ebf9cfdcf47798901ef251f43737e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_14,color_FFFFFF,t_70,g_se,x_16" alt="6.1" style="zoom:60%;" /><p>在vue3当中，我们可以对传递的参数进行验证：</p> <img src="https://img-blog.csdnimg.cn/e83edf1d71f448b2b0421f383584ef4e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_19,color_FFFFFF,t_70,g_se,x_16" alt="6.2" style="zoom:50%;" /><h2 id="7-非父子组件的通信"><a href="#7-非父子组件的通信" class="headerlink" title="7. 非父子组件的通信"></a>7. 非父子组件的通信</h2><p>在开发中，我们构建了组件树之后，除了<strong>父子组件之间的通信</strong>之外，还会有<strong>非父子组件之间的通信</strong>。</p><p>这里我们主要将两种方式：</p><ul><li>Provide&#x2F;Inject；</li><li>Mitt全局时间总线。</li></ul><h3 id="7-1-Provide和Inject"><a href="#7-1-Provide和Inject" class="headerlink" title="7.1 Provide和Inject"></a>7.1 Provide和Inject</h3><p>Provide&#x2F;Inject用于非父子组件之间共享数据：</p><p>比如有一些深度嵌套的组件，子组件想要获取父组件的部分内容。在这种情况下，如果我们仍然将props沿着组件链逐级传递下去，就会非常麻烦。</p><p>对于这种情况下，我们可以使用Provide和Inject：</p><ul><li>无论层级结构有多深，父组件都可以作为其所有子组件的依赖提供者；</li><li>父组件有一个provide选项来提供数据；</li><li>子组件有一个inject选项来开始使用这些数据。</li></ul><p>实际上，你可以将依赖注入看作是“long range props”，除了：</p><ul><li>父组件不需要知道哪些子组件使用它的provide的property</li><li>子组件不需要知道inject的property来自哪里</li></ul><img src="https://img-blog.csdnimg.cn/31e2d94890af46c2876de5c659bd213f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_19,color_FFFFFF,t_70,g_se,x_16" alt="7.1" style="zoom:50%;" /><p><strong>7.1.1 Provide和Inject基本使用</strong></p><p>我们开发一个这样的结构：</p><p><img src="https://img-blog.csdnimg.cn/285c82834fb04a63bb7d81bde8bcb624.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="7.1.1"></p><img src="https://img-blog.csdnimg.cn/d07eb04458bd4084b914754cc3bb22bc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="7.1.2" style="zoom:70%;" /><p><strong>7.1.2 Provide和Inject函数的写法</strong></p><p>如果Provide中提供的一些数据是来自data，那么我们可能想要通过this来获取：</p><p>这个时候会报错：</p><p>我们要先想清楚这个this是指哪里的this。</p><img src="https://img-blog.csdnimg.cn/55f5396ab7b949839489fb89c76e1f76.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="7.1.3" style="zoom:67%;" /><p> <strong>7.1.3 处理响应式数据</strong></p><p>我们先来验证一个结果：如果我们修改了this.names的内容，那么使用length的子组件会不会是响应式的？</p><p>实践发现，对应的子组件中是没有反应的：</p><p>这是因为当我们修改了names之后，之前在provide中引入的this.names.length本身并不是响应式的。</p><p>那么，怎么样可以让我们的数据变成响应式的呢？</p><p>我们可以使用响应式的一些API来完成这些功能，比如说computed函数。</p><blockquote><p>注：computed是vue3的新特性，可以查看官方文档。</p></blockquote><p>我们在使用length的时候需要获取其中的value，这是因为computed反悔的是一个ref对象，需要取出其中的value来使用。</p><img src="https://img-blog.csdnimg.cn/caf5a5347b20469da644570321fda649.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="7.1.4" style="zoom:67%;" /><h3 id="7-2-全局事件总线mitt库"><a href="#7-2-全局事件总线mitt库" class="headerlink" title="7.2 全局事件总线mitt库"></a>7.2 全局事件总线mitt库</h3><p>Vue3从实例中移除了$on、$off和$once方法，所以我们如果希望继续使用全局事件组件，要通过第三方库：</p><ul><li>Vue3官方有推荐一些库，例如mitt或tine-emitter；</li></ul><p>首先我们需要先在项目目录下安装这个库：</p><pre><code>npm install mitt</code></pre><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p> 其次，我们可以封装一个工具eventbus.js：</p><img src="https://img-blog.csdnimg.cn/f32b9754c4d44722b1c1cf4f3d15dd54.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_12,color_FFFFFF,t_70,g_se,x_16" alt="7.2.1" style="zoom:67%;" /><p> <strong>7.2.1 使用事件总线工具</strong></p><p>在项目中可以使用它们：</p><ul><li>我们在Home.vue中监听事件；</li><li>我们在App.vue中触发事件。</li></ul><img src="https://img-blog.csdnimg.cn/18570abf7edb470589651cca7989b104.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="7.2.2" style="zoom:67%;" /><p> <strong>7.2.2 Mitt的时间取消</strong></p><pre><code>//取消emitter中所有的监听emitter.all.clear()//定义一个函数function onFoo()&#123;&#125;emitter.on(&#39;foo&#39;,onFoo)   //监听emitter.off(&#39;foo&#39;,onFoo)  //取消监听</code></pre><h2 id="8-插槽Slot"><a href="#8-插槽Slot" class="headerlink" title="8. 插槽Slot"></a>8. 插槽Slot</h2><p>在开发中，我们会经常封装一个个可复用的组件：</p><p>前面我们会通过props传递给组件一些数据，让组件来进行展示，但是为了让这个组件具备更强的通用性，我们不能将组件中的内容限制为固定的div、span等等这些元素。</p><p>比如某种情况下我们使用组件，希望组件显示的是一个按钮，某种情况下我们使用组件希望显示的是一张图片，我们应该让使用者决定某一块区域到底存放什么元素与内容。</p><p><strong>举个例子：加入我们定制一个通用的导航组件-NavBar</strong></p><p>这个组件分成三块区域：左边-中间-右边，每块区域的内容是不固定。</p><ul><li>左边区域可能显示一个菜单图标，也可能显示一个返回按钮，可能什么都不显示；</li><li>中间区域可能显示一个搜索框，也可能是一个列表，也可能是一个标题，等等；</li><li>右边区域可能是一个文字，也可能是一个图标，也可能什么都不显示。</li></ul><img src="https://img-blog.csdnimg.cn/2dc7f24d250d42378a2ac2359ad96f12.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="8.1" style="zoom:67%;" /><h3 id="8-1-如何使用插槽slot？"><a href="#8-1-如何使用插槽slot？" class="headerlink" title="8.1 如何使用插槽slot？"></a>8.1 如何使用插槽slot？</h3><p>（1）这个时候我们就可以来定义插槽slot：</p><ul><li>插槽的使用过程其实是<strong>抽取共性、预留不同</strong>；</li><li>我们会将共同的元素、内容依然在组件内进行封装；</li><li>同时将不同的元素使用slot作为占位，让外部决定到底显示什么样的元素。</li></ul><p>（2）如何使用slot？</p><ul><li>Vue中将<slot>元素作为承载分发内容的出口；</li><li>在封装组件中，使用特殊的元素<slot>就可以封装组件开启一个插槽；</li><li>该插槽插入什么内容取决于父组件如何使用。</li></ul><h3 id="8-2-插槽的基本使用"><a href="#8-2-插槽的基本使用" class="headerlink" title="8.2 插槽的基本使用"></a>8.2 插槽的基本使用</h3><p>我们一个组件MySlotCpn.vue：该组件中有一个插槽，我们可以在插槽中放入显示的内容，我们在App.vue中使用它们：我们可以插入普通的内容、html元素、组件元素，都可以是可以的。</p><img src="https://img-blog.csdnimg.cn/507365daefe44e05ae992b7304ee7714.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="8.2.1" style="zoom:67%;" /><p> <strong>8.2.1 插槽的默认内容</strong></p><p>有时候我们希望在使用插槽时，如果没有插入对应的内容，那么我们需要显示一个默认的内容：</p><p>当然这个默认的内容只会在没有提供插入的内容时，才会显示。</p><img src="https://img-blog.csdnimg.cn/975e0eae6789484d94fbb152a3b49ec1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="8.2.2" style="zoom:67%;" /><p><strong>8.2.2 多个插槽的效果</strong></p><p>我们先测试一个知识点：如果一个组件中含有多个插槽，我们插入多个内容时是什么效果？</p><p>我们会发现默认情况下每个插槽都会获取到我们插入的内容来显示。</p><img src="https://img-blog.csdnimg.cn/322441eb9f314078868fd64b9d951e0d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="8.2.3" style="zoom:67%;" /><h3 id="8-3-具名插槽的作用"><a href="#8-3-具名插槽的作用" class="headerlink" title="8.3 具名插槽的作用"></a>8.3 具名插槽的作用</h3><p>事实上，我们希望达到的效果时插槽对应的显示，这个时候我们就可以使用具名插槽：</p><ul><li>具名茶擦顾名思义就是给插槽起一个名字，<slot>元素有一个特殊的attribute：name；</li><li>一个不带name的slot，会带有隐含的名字default。</li></ul><img src="https://img-blog.csdnimg.cn/96a9f24a53554cd79955847dfc8bd152.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="8.3.1" style="zoom:67%;" /><p><strong>8.3.1 动态插槽名</strong></p><p>（1）什么是动态插槽名？</p><p>目前我们使用的插槽名称都是固定的，比如v-slot：left、v-slot：center等等。我们可以通过v-slot:[dynamicSlotName]方式动态绑定一个名称。</p><img src="https://img-blog.csdnimg.cn/6692a6da28c1401292579e5d303033b6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_18,color_FFFFFF,t_70,g_se,x_16" alt="8.3.1" style="zoom:67%;" /><p>（2）具名插槽使用时的缩写</p><p>跟v-on和v-bind一样，v-slot也有缩写，即**把参数之前的所有内容（v-slot：）替换为字符#**。</p><img src="https://img-blog.csdnimg.cn/985f0070c48443cc9d3e1408abc05f08.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_10,color_FFFFFF,t_70,g_se,x_16" alt="8.3.2" style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-认识组件的嵌套&quot;&gt;&lt;a href=&quot;#1-认识组件的嵌套&quot; class=&quot;headerlink&quot; title=&quot;1.认识组件的嵌套&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.认识组件的嵌套&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;前面我们是将所有的逻辑放到一个Ap</summary>
      
    
    
    
    
    <category term="vue3" scheme="http://sang63.github.io/tags/vue3/"/>
    
  </entry>
  
  <entry>
    <title>VueCLI和Vite</title>
    <link href="http://sang63.github.io/2022/03/30/VueCLI%E5%92%8CVite/"/>
    <id>http://sang63.github.io/2022/03/30/VueCLI%E5%92%8CVite/</id>
    <published>2022-03-30T01:01:46.000Z</published>
    <updated>2022-03-30T01:30:29.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-VueCLI"><a href="#1-VueCLI" class="headerlink" title="1. VueCLI"></a>1. VueCLI</h2><h3 id="1-1-Vue-CLI脚手架"><a href="#1-1-Vue-CLI脚手架" class="headerlink" title="1.1 Vue CLI脚手架"></a><strong>1</strong>.1 Vue CLI脚手架</h3><p>什么是Vue脚手架？ </p><ul><li>我们前面学习了如何通过webpack配置Vue的开发环境，但是在真实开发中我们不可能每一个项目从头来完成所有的webpack配置，这样显示开发的效率会大大的降低； </li><li>所以在真实开发中，我们通常会使用脚手架来创建一个项目，Vue的项目我们使用的就是Vue的脚手架； </li><li>脚手架其实是建筑工程中的一个概念，在我们软件工程中也会将一些帮助我们搭建项目的工具称之为脚手架。</li></ul><p>Vue的脚手架就是Vue CLI： </p><ul><li>CLI是Command-Line Interface, 翻译为命令行界面； </li><li>我们可以通过CLI选择项目的配置和创建出我们的项目； </li><li>Vue CLI已经内置了webpack相关的配置，我们不需要从零来配置。</li></ul><h3 id="1-2-Vue-CLI-安装和使用"><a href="#1-2-Vue-CLI-安装和使用" class="headerlink" title="1.2 Vue CLI 安装和使用"></a>1.2 <strong>Vue CLI 安装和使用</strong></h3><ul><li>安装最新版本的Vue CLI。当我们进行全局安装时，安装后的Vue CLI在任何时候都可以通过vue的命令来创建项目；</li></ul><pre><code>npm install @vue/cli -g</code></pre><ul><li>升级Vue CLI。 如果是比较旧的版本，可以通过下面的命令来升级；</li></ul><pre><code>npm update @vue/cli -g</code></pre><ul><li>通过Vue的命令来创建项目。</li></ul><pre><code>vue create 项目的名称</code></pre><h3 id="1-3-vue-create-项目的过程"><a href="#1-3-vue-create-项目的过程" class="headerlink" title="1.3 vue create 项目的过程"></a><strong>1.3 vue create 项目的过程</strong></h3><p><img src="https://img-blog.csdnimg.cn/c59ff06e117c4fb3931c0bff5f98e5ac.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图 1.3.1" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/37b3fc80dfae4521a14a8e32f083d1bb.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图 1.3.2" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/d33c699863c64cefbdbaeb261c9b2697.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图 1.3.3" style="zoom:60%;" /></p><h3 id="1-4-项目的目录结构"><a href="#1-4-项目的目录结构" class="headerlink" title="1.4 项目的目录结构"></a>1.4 <strong>项目的目录结构</strong></h3><p><img src="https://img-blog.csdnimg.cn/31fc26b64b254df78c8b62ac78ae52c9.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_16,color_FFFFFF,t_70,g_se,x_16" alt="图 1.4.1" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/e767edabb78f49e3a6f624a9280afa2f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_18,color_FFFFFF,t_70,g_se,x_16" alt="图 1.4.2" style="zoom:50%;" /></p><h3 id="1-5-Vue-CLI的运行原理"><a href="#1-5-Vue-CLI的运行原理" class="headerlink" title="1.5 Vue CLI的运行原理"></a>1.5 <strong>Vue CLI的运行原理</strong></h3><h3 id=""><a href="#" class="headerlink" title=""></a><img src="https://img-blog.csdnimg.cn/0c13ec38ce3a40e18371c8f33d532d2a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图 1.5.1" style="zoom:67%;" /></h3><h2 id="2-vite"><a href="#2-vite" class="headerlink" title="2. vite"></a>2. vite</h2><h3 id="2-1-认识vite"><a href="#2-1-认识vite" class="headerlink" title="2.1 认识vite"></a>2.1 认识vite</h3><ul><li>Webpack是目前整个前端使用最多的构建工具，但是除了webpack之后也有其他的一些构建工具：比如rollup、parcel、gulp、vite等等 。</li><li>什么是vite呢？官方的定位：下一代前端开发与构建工具； </li><li>如何定义下一代开发和构建工具呢？ 我们知道在实际开发中，我们编写的代码往往是不能被浏览器直接识别的，比如ES6、TypeScript、Vue文件等等； 所以我们必须通过构建工具来对代码进行转换、编译，类似的工具有webpack、rollup、parcel。</li></ul><p>但是随着项目越来越大，需要处理的JavaScript呈指数级增长，模块越来越多； </p><p>构建工具需要很长的时间才能开启服务器，HMR也需要几秒钟才能在浏览器反应出来； </p><p>所以也有这样的说法：天下苦webpack久矣； </p><p>Vite (法语意为 “快速的”，发音 &#x2F;vit&#x2F;) 是一种新型前端构建工具，能够显著提升前端开发体验。</p><h3 id="2-2-Vite的构造"><a href="#2-2-Vite的构造" class="headerlink" title="2.2 Vite的构造"></a>2.2 <strong>Vite的构造</strong></h3><p>它主要由两部分组成： </p><ul><li>一个开发服务器，它基于原生ES模块提供了丰富的内建功能，HMR的速度非常快速； </li><li>一套构建指令，它使用rollup打开我们的代码，并且它是预配置的，可以输出生成环境的优化过的静态资源。</li></ul><p>目前是否要大力学习vite？vite的未来是怎么样的？ </p><ul><li>我个人非常看好vite的未来，也希望它可以有更好的发展； </li><li>但是，目前vite虽然已经更新到2.0，依然并不算非常的稳定，并且比较少大型项目（或框架）使用vite来进行构建； </li><li>vite的整个社区插件等支持也还不够完善； </li><li>包括vue脚手架本身，目前也还没有打算迁移到vite，而依然使用webpack（虽然后期一定是有这个打算的）；</li></ul><p>所以vite看起来非常的火热，在面试也可能会问到，但是实际项目中应用的还比较少；</p><h3 id="2-3-浏览器原生支持模块化"><a href="#2-3-浏览器原生支持模块化" class="headerlink" title="2.3 浏览器原生支持模块化"></a>2.3 <strong>浏览器原生支持模块化</strong></h3><h3 id="-1"><a href="#-1" class="headerlink" title=""></a><img src="https://img-blog.csdnimg.cn/62893806d9554a34aaaaae080b094a45.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图 2.3.1" style="zoom:50%;" /></h3><p>但是如果我们不借助于其他工具，直接使用ES Module来开发有什么问题呢？ </p><ul><li>首先，我们会发现在使用loadash时，加载了上百个模块的js代码，对于浏览器发送请求是巨大的消耗； </li><li>其次，我们的代码中如果有TypeScript、less、vue等代码时，浏览器并不能直接识别；</li></ul><p>事实上，vite就帮助我们解决了上面的所有问题。</p><p>2.4 <strong>Vite的安装和使用</strong><br> 注意：Vite本身也是依赖Node的，所以也需要安装好Node环境并且Vite要求Node版本是大于12版本的； </p><ul><li>首先，我们安装一下vite工具：</li></ul><pre><code>npm install vite –g # 全局安装npm install vite –D # 局部安装</code></pre><ul><li>通过vite来启动项目：</li></ul><pre><code>npx vite</code></pre><h3 id="2-5-Vite对css的支持"><a href="#2-5-Vite对css的支持" class="headerlink" title="2.5 Vite对css的支持"></a>2.5 <strong>Vite对css的支持</strong></h3><p>vite可以直接支持css的处理：直接导入css即可； </p><p>vite可以直接支持css预处理器，比如less </p><ul><li>直接导入less；</li><li>之后安装less编译器；</li></ul><pre><code>npm install less -D</code></pre><p>vite直接支持postcss的转换： </p><ul><li>只需要安装postcss，并且配置 postcss.config.js 的配置文件即可；</li></ul><pre><code>npm install postcss postcss-preset-env -D</code></pre><img src="https://img-blog.csdnimg.cn/de3d9fe577f945a1b136e2e6785e185e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_18,color_FFFFFF,t_70,g_se,x_16" alt="图 2.5.1" style="zoom:67%;" /><h3 id="2-6-Vite对TypeScript的支持"><a href="#2-6-Vite对TypeScript的支持" class="headerlink" title="2.6 Vite对TypeScript的支持"></a>2.6 <strong>Vite对TypeScript的支持</strong></h3><p>vite对TypeScript是原生支持的，它会直接使用ESBuild来完成编译： </p><ul><li>只需要直接导入即可；</li></ul><p>如果我们查看浏览器中的请求，会发现请求的依然是ts的代码： </p><ul><li>这是因为vite中的服务器Connect会对我们的请求进行转发； </li><li>获取ts编译后的代码，给浏览器返回，浏览器可以直接进行解析；</li></ul><p>注意：在vite2中，已经不再使用Koa了，而是使用Connect来搭建的服务器</p><img src="https://img-blog.csdnimg.cn/a0b19aa890e94745bc6cd82b83856404.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图 2.6.1" style="zoom:80%;" /><h3 id="2-7-Vite对vue的支持"><a href="#2-7-Vite对vue的支持" class="headerlink" title="2.7 Vite对vue的支持"></a>2.7 <strong>Vite对vue的支持</strong></h3><p>vite对vue提供第一优先级支持： </p><ul><li>Vue 3 单文件组件支持：@vitejs&#x2F;plugin-vue </li><li>Vue 3 JSX 支持：@vitejs&#x2F;plugin-vue-jsx </li><li>Vue 2 支持：underfin&#x2F;vite-plugin-vue2</li></ul><p>安装支持vue的插件：</p><pre><code>npm install @vitejs/plugin-vue -D</code></pre><p>在vite.config.js中配置插件：</p><img src="https://img-blog.csdnimg.cn/77cbd85fb8814cbd9aacd44d99e5660b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_17,color_FFFFFF,t_70,g_se,x_16" alt="图 2.7.1" style="zoom:67%;" /><h3 id="2-8-Vite打包项目"><a href="#2-8-Vite打包项目" class="headerlink" title="2.8 Vite打包项目"></a>2.8 <strong>Vite打包项目</strong></h3><p>我们可以直接通过vite build来完成对当前项目的打包工具：</p><pre><code>npx vite build</code></pre><img src="https://img-blog.csdnimg.cn/06034bd015a946e2b82e89cace64fe70.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_15,color_FFFFFF,t_70,g_se,x_16" alt="图 2.8.1" style="zoom:67%;" /><p>我们可以通过preview的方式，开启一个本地服务来预览打包后的效果：</p><pre><code>npx vite preview</code></pre><h3 id="2-9-ESBuild解析"><a href="#2-9-ESBuild解析" class="headerlink" title="2.9 ESBuild解析"></a>2.9 <strong>ESBuild解析</strong></h3><p>ESBuild的特点： </p><ul><li>超快的构建速度，并且不需要缓存； </li><li>支持ES6和CommonJS的模块化； </li><li>支持ES6的Tree Shaking； </li><li>支持Go、JavaScript的API； </li><li>支持TypeScript、JSX等语法编译； </li><li>支持SourceMap； </li><li>支持代码压缩； </li><li>支持扩展其他插件；</li></ul><h3 id="2-10-ESBuild的构建速度"><a href="#2-10-ESBuild的构建速度" class="headerlink" title="2.10 ESBuild的构建速度"></a>2.10 <strong>ESBuild的构建速度</strong></h3><img src="https://img-blog.csdnimg.cn/dbf3aa6ac0974acea9dc1c48bfa78ed4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="图 2.10.1" style="zoom:80%;" /><p>ESBuild为什么这么快呢？ </p><ul><li>使用Go语言编写的，可以直接转换成机器代码，而无需经过字节码； </li><li>ESBuild可以充分利用CPU的多内核，尽可能让它们饱和运行； </li><li>ESBuild的所有内容都是从零开始编写的，而不是使用第三方，所以从一开始就可以考虑各种性能问题； </li><li>等等….</li></ul><h3 id="2-11-Vite脚手架工具"><a href="#2-11-Vite脚手架工具" class="headerlink" title="2.11 Vite脚手架工具"></a><strong>2.11 Vite脚手架工具</strong></h3><p>在开发中，我们不可能所有的项目都使用vite从零去搭建，比如一个react项目、Vue项目；这个时候vite还给我们提供了对应的脚手架工具；</p><p>所以Vite实际上是有两个工具的： </p><ul><li>vite：相当于是一个构件工具，类似于webpack、rollup； </li><li>@vitejs&#x2F;create-app：类似vue-cli、create-react-app；</li></ul><p>如果使用脚手架工具呢？</p><pre><code>npm init @vitejs/app</code></pre><p>上面的做法相当于省略了安装脚手架的过程：</p><pre><code>npm install @vitejs/create-app -gcreate-app</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-VueCLI&quot;&gt;&lt;a href=&quot;#1-VueCLI&quot; class=&quot;headerlink&quot; title=&quot;1. VueCLI&quot;&gt;&lt;/a&gt;1. VueCLI&lt;/h2&gt;&lt;h3 id=&quot;1-1-Vue-CLI脚手架&quot;&gt;&lt;a href=&quot;#1-1-Vue-CLI脚手</summary>
      
    
    
    
    
    <category term="Vue3" scheme="http://sang63.github.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>Vue3的Options-API</title>
    <link href="http://sang63.github.io/2022/03/17/Vue3%E7%9A%84Options-API/"/>
    <id>http://sang63.github.io/2022/03/17/Vue3%E7%9A%84Options-API/</id>
    <published>2022-03-17T06:40:28.000Z</published>
    <updated>2022-03-30T01:30:12.466Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-复杂data的处理方式"><a href="#1-复杂data的处理方式" class="headerlink" title="1. 复杂data的处理方式"></a>1. 复杂data的处理方式</h2><p>我们知道，在模板中可以直接通过<strong>插值语法</strong>显示一些<strong>data中的数据</strong>。但是在某些情况，我们可能需要对<strong>数据进行一些转化后</strong>再显示，或者需要<strong>将多个数据结合起来</strong>进行显示；  </p><ul><li>比如我们需要对多个data数据进行运算、三元运算符来决定结果、数据进行某种转化后显示； </li><li>在模板中使用表达式，可以非常方便的实现，但是设计它们的初衷是用于简单的运算； </li><li>在模板中放入太多的逻辑会让模板过重和难以维护；</li></ul><p>并且如果多个地方都使用到，那么会有大量重复的代码； 我们有没有什么方法可以将逻辑抽离出去呢？ </p><ul><li>可以，其中一种方式就是将逻辑抽取到一个method中，放到methods的options中； </li><li>但是，这种做法有一个直观的弊端，就是所有的data使用过程都会变成了一个方法的调用； </li><li>另外一种方式就是使用计算属性computed；</li></ul><h2 id="2-认识计算属性computed"><a href="#2-认识计算属性computed" class="headerlink" title="2.认识计算属性computed"></a>2.认识计算属性computed</h2><h3 id="2-1-什么是计算属性呢？"><a href="#2-1-什么是计算属性呢？" class="headerlink" title="2.1 什么是计算属性呢？"></a><strong>2.1 什么是计算属性呢？</strong></h3><p> 官方并没有给出直接的概念解释；而是说：对于任何包含响应式数据的复杂逻辑，你都应该使用<strong>计算属性</strong>； </p><p>计算属性将被混入到组件实例中。所有 getter 和 setter 的 this 上下文自动地绑定为组件实例； </p><p>计算属性的用法： </p><ul><li><p><strong>选项：</strong>computed </p></li><li><p><strong>类型：</strong>{ [key: string]: Function | { get: Function, set: Function } } </p><p> 那接下来我们通过案例来理解一下这个计算属性。</p></li></ul><h3 id="2-2案例实现思路"><a href="#2-2案例实现思路" class="headerlink" title="2.2案例实现思路"></a>2.2案例实现思路</h3><p><strong>我们来看三个案例：</strong> </p><ul><li>案例一：我们有两个变量：firstName和lastName，希望它们拼接之后在界面上显示； </li><li>案例二：我们有一个分数：score ，当score大于60的时候，在界面上显示及格； 当score小于60的时候，在界面上显示不及格； </li><li>案例三：我们有一个变量message，记录一段文字：比如Hello World 某些情况下我们是直接显示这段文字；某些情况下我们需要对这段文字进行反转；</li></ul><p><strong>我们可以有三种实现思路：</strong> </p><ul><li>思路一：在模板语法中直接使用表达式； </li><li>思路二：使用method对逻辑进行抽取； </li><li>思路三：使用计算属性computed；</li></ul><p><strong>2.2.1实现思路一：模板语法</strong></p><ul><li>缺点一：模板中存在大量的复杂逻辑，不便于维护（模板中表达式的初衷是用于简单的计算）； </li><li>缺点二：当有多次一样的逻辑时，存在重复的代码； </li><li>缺点三：多次使用的时候，很多运算也需要多次执行，没有缓存；</li></ul><img src="https://img-blog.csdnimg.cn/e9e0360ea5ff41598c948151641dcb49.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="01" style="zoom:50%;" /><p> 2.2.2<strong>思路二的实现：method实现</strong></p><ul><li>缺点一：我们事实上先显示的是一个结果，但是都变成了一种方法的调用；</li><li>缺点二：多次使用方法的时候，没有缓存，也需要多次计算；</li></ul><p> <img src="https://img-blog.csdnimg.cn/4a9f42726844473fa726a9671367009d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="02" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/436667bc05964b5792628e3a6a06d56e.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="03" style="zoom:50%;" /></p><p><strong>2.2.3思路三的实现：computed实现</strong></p><ul><li>注意：计算属性看起来像是一个函数，但是我们在使用的时候不需要加()，这个后面讲setter和getter时会说到；</li><li>我们会发现无论是直观上，还是效果上计算属性都是更好的选择； </li><li>并且计算属性是有缓存的；</li></ul><p> <img src="https://img-blog.csdnimg.cn/a3c50eaa80b74985ab72ef4e0eb75986.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="04" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/1897912da47440f28d8191a15d75ff8b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="05" style="zoom:50%;" /><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><h2 id="3-计算属性-vs-methods"><a href="#3-计算属性-vs-methods" class="headerlink" title="3.计算属性 vs methods"></a>3.计算属性 vs methods</h2><p>在上面的实现思路中，我们会发现计算属性和methods的实现看起来是差别是不大的，而且我们多次提到计算属性有缓存的。</p><p>接下来我们来看一下同一个计算多次使用，计算属性和methods的差异：</p><p> <img src="https://img-blog.csdnimg.cn/c5217f50b8914f16a87122414e1490b7.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="06"></p><h3 id="3-1计算属性的缓存"><a href="#3-1计算属性的缓存" class="headerlink" title="3.1计算属性的缓存"></a>3.1<strong>计算属性的缓存</strong></h3><p>这是什么原因呢？ </p><ul><li>这是因为计算属性会基于它们的依赖关系进行缓存； </li><li>在数据不发生变化时，计算属性是不需要重新计算的； </li><li>但是如果依赖的数据发生变化，在使用时，计算属性依然会重新进行计算；</li></ul> <img src="https://img-blog.csdnimg.cn/24104796be8b42afbaac29055a311f1c.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="07" style="zoom:50%;" /><h3 id="3-2计算属性的setter和getter"><a href="#3-2计算属性的setter和getter" class="headerlink" title="3.2计算属性的setter和getter"></a><strong>3.2计算属性的setter和getter</strong></h3><p>​    计算属性在大多数情况下，只需要一个<strong>getter方法</strong>即可，所以我们会将计算属性直接<strong>写成一个函数</strong>。</p><p>​    但是，如果我们确实想<strong>设置计算属性的值</strong>呢？ </p><p>​    这个时候我们也可以给计算属性设置一个setter的方法；</p><img src="https://img-blog.csdnimg.cn/95aaf2c8f0da40cb8a6ad284006df106.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="08" style="zoom:50%;" /><h3 id="3-3源码如何对setter和getter处理呢？"><a href="#3-3源码如何对setter和getter处理呢？" class="headerlink" title="3.3源码如何对setter和getter处理呢？"></a>3.3<strong>源码如何对setter和getter处理呢？</strong></h3><p>你可能觉得很奇怪，Vue内部是如何对我们传入的是一个getter，还是说是一个包含setter和getter的对象进行处理的呢？  </p><p>事实上非常的简单，Vue源码内部只是做了一个逻辑判断而已；</p><img src="https://img-blog.csdnimg.cn/7bacbdb715ec4facb24e0db11270bcc2.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="09" style="zoom:50%;" /><h3 id="3-4认识侦听器watch"><a href="#3-4认识侦听器watch" class="headerlink" title="3.4认识侦听器watch"></a>3.4<strong>认识侦听器watch</strong></h3><p><strong>3.4.1什么是侦听器呢？</strong></p><ul><li>开发中我们在data返回的对象中定义了数据，这个数据通过插值语法等方式绑定到template中； </li><li>当数据变化时，template会自动进行更新来显示最新的数据； </li><li>但是在某些情况下，我们希望在代码逻辑中监听某个数据的变化，这个时候就需要用侦听器watch来完成了；</li></ul><p><strong>3.4.2侦听器的用法如下：</strong> </p><ul><li><strong>选项：</strong>watch </li><li><strong>类型：</strong>{ [key: string]: string | Function | Object | Array}</li></ul><p><strong>3.4.3侦听器案例</strong></p><p><strong>举个栗子（例子）：</strong></p><p> 比如现在我们希望用户在input中输入一个问题；每当用户输入了最新的内容，我们就获取到最新的内容，并且使用该问题去服务器查询答案；那么，我们就需要实时的去获取最新的数据变化；</p><p> <img src="https://img-blog.csdnimg.cn/1598e06873584d2bbc49a48870ff24d6.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="10"></p><p><strong>3.4.4侦听器watch的配置选项</strong></p><p>我们先来看一个例子： </p><p> 当我们点击按钮的时候会修改info.name的值； </p><p> 这个时候我们使用watch来侦听info，可以侦听到吗？答案是不可以。 </p><p> 这是因为默认情况下，<strong>watch只是在侦听info的引用变化</strong>，对于<strong>内部属性的变化是不会做出响应</strong>的： </p><p> 这个时候我们可以使用一个选项deep进行更深层的侦听； </p><p> 注意前面我们说过watch里面侦听的属性对应的也可以是一个Object； </p><p> 还有<strong>另外一个属性</strong>，是<strong>希望一开始的就会立即执行一次</strong>： </p><p> 这个时候我们使用immediate选项； </p><p> 这个时候无论后面数据是否有变化，侦听的函数都会有限执行一次；</p><img src="https://img-blog.csdnimg.cn/4fd3fe1d53ad48eab9fdf2e59e01223a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="11" style="zoom:50%;" /><p><strong>3.4.5侦听器watch的其他方式（一）</strong></p><p> <img src="https://img-blog.csdnimg.cn/4dbc6123aabb45fc9d4129db21749565.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_10,color_FFFFFF,t_70,g_se,x_16" alt="12" style="zoom:80%;" /><img src="https://img-blog.csdnimg.cn/b6288992aa9746fd9cf50564fe0b4b4d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="13" style="zoom:50%;" /></p><p>另外一个是Vue3文档中没有提到的，但是Vue2文档中有提到的是侦听对象的属性：</p><img src="https://img-blog.csdnimg.cn/144edf0a63e744589f03d0baba68c3bc.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="14" style="zoom:80%;" /><p><strong>还有另外一种方式就是使用 $watch 的API：</strong></p><p>我们可以在created的生命周期（后续会讲到）中，使用 this.$watchs 来侦听； </p><ul><li>第一个参数是要侦听的源； </li><li>第二个参数是侦听的回调函数callback； </li><li>第三个参数是额外的其他选项，比如deep、immediate；</li></ul><img src="https://img-blog.csdnimg.cn/d088c38bc1dc4a4bb26ea28552af1ea0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="15" style="zoom:50%;" /><h2 id="4-综合案例"><a href="#4-综合案例" class="headerlink" title="4.综合案例"></a>4.综合案例</h2><p>现在我们来做一个相对综合一点的练习：<strong>书籍购物车</strong></p><p><img src="https://img-blog.csdnimg.cn/f5a43e94eb9f4a2daba19b0d28b53529.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="16"></p><p>案例说明： </p><ul><li>在界面上以表格的形式，显示一些书籍的数据； </li><li>在底部显示书籍的总价格； </li><li>点击+或者-可以增加或减少书籍数量（如果为1，那么不能继续-）； </li><li>点击移除按钮，可以将书籍移除（当所有的书籍移除完毕时，显示：购物车为空~）；</li></ul><h2 id="5-v-model"><a href="#5-v-model" class="headerlink" title="5.v-model"></a>5.<strong>v-model</strong></h2><h3 id="5-1v-model的基本使用"><a href="#5-1v-model的基本使用" class="headerlink" title="5.1v-model的基本使用"></a><strong>5.1v-model的基本使用</strong></h3><p><strong>表单提交</strong>是开发中非常常见的功能，也是和用户交互的重要手段： </p><p>比如用户在登录、注册时需要提交账号密码； </p><p>比如用户在检索、创建、更新信息时，需要提交一些数据； </p><p>这些都要求我们可以在<strong>代码逻辑中获取到用户提交的数据</strong>，我们通常会使用<strong>v-model指令</strong>来完成： v-model指令可以在表单 input、textarea以及select元素上创建双向数据绑定； </p><p>它会根据控件类型自动选取正确的方法来更新元素； 尽管有些神奇，但 v-model 本质上不过是语法糖，它负责监听用户的输入事件来更新数据，并在某种极端场景下进行一些特殊处理；</p><p><img src="https://img-blog.csdnimg.cn/af95bd6e85ff45b49437c7659303afe1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="17"></p><h3 id="5-2v-model的原理"><a href="#5-2v-model的原理" class="headerlink" title="5.2v-model的原理"></a>5.2<strong>v-model的原理</strong></h3><p>官方有说到，<strong>v-model的原理</strong>其实是背后有两个操作： </p><ul><li>v-bind绑定value属性的值； </li><li>v-on绑定input事件监听到函数中，函数会获取最新的值赋值到绑定的属性中；</li></ul><pre><code>&lt;input v-model=&quot;searchText&quot; /&gt;等价于：&lt;input :value=&quot;searchText&quot; @input=&quot;searchTect=$event.target.value&quot; /&gt;</code></pre><p> 事实上，v-model更加复杂：</p><p><img src="https://img-blog.csdnimg.cn/16ffc617841641e8bd026a86a1729c05.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="18"><strong>5.3v-model绑定textarea</strong></p><p>我们再来绑定一下<strong>其他的表单类型</strong>：textarea、checkbox、radio、select </p><p>我们来看一下绑定textarea：</p><img src="https://img-blog.csdnimg.cn/bed70c33a36c4bd8810b0eb2425cfc38.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="19" style="zoom:50%;" /><h3 id="5-4v-model绑定checkbox"><a href="#5-4v-model绑定checkbox" class="headerlink" title="5.4v-model绑定checkbox"></a>5.4<strong>v-model绑定checkbox</strong></h3><p>我们来看一下v-model绑定<strong>checkbox</strong>：单个勾选框和多个勾选框 </p><ul><li><p><strong>单个勾选框：</strong> </p><p>v-model即为布尔值。此时input的value并不影响v-model的值。 </p></li><li><p><strong>多个复选框：</strong> </p><p>当是多个复选框时，因为可以选中多个，所以对应的data中属性是一个数组。当选中某一个时，就会将input的value添加到数组中。</p></li></ul><p><img src="https://img-blog.csdnimg.cn/d5133e723942429e822a4e02cbcaaa42.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="20" style="zoom:50%;" /><img src="https://img-blog.csdnimg.cn/7e199cd2b42c47a4bd7754ba44e2bc31.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="21" style="zoom:50%;" /></p><p>5.5<strong>v-model绑定radio</strong></p><p>v-model绑定<strong>radio</strong>，用于选择其中一项；</p><img src="https://img-blog.csdnimg.cn/7968b15cacda4989953afa7c3bd1123d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="22" style="zoom:50%;" /><h3 id="5-6v-model绑定select"><a href="#5-6v-model绑定select" class="headerlink" title="5.6v-model绑定select"></a><strong>5.6v-model绑定select</strong></h3><p><strong>和checkbox一样，select也分单选和多选两种情况。</strong> </p><p><strong>单选：只能选中一个值</strong> </p><p>  v-model绑定的是一个值； </p><p> 当我们选中option中的一个时，会将它对应的value赋值到fruit中； </p><p><strong>多选：可以选中多个值</strong> </p><p>  v-model绑定的是一个数组； </p><p> 当选中多个值时，就会将选中的option对应的value添加到数组fruit中；</p><p><img src="https://img-blog.csdnimg.cn/c7dfccaa41e04e17bb811a338262fa1b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="23"></p><h3 id="5-7v-model的值绑定"><a href="#5-7v-model的值绑定" class="headerlink" title="5.7v-model的值绑定"></a><strong>5.7v-model的值绑定</strong></h3><p>目前我们在前面的案例中大部分的值都是在template中固定好的： </p><ul><li>比如gender的两个输入框值male、female； </li><li>比如hobbies的三个输入框值basketball、football、tennis；</li></ul><p>在真实开发中，我们的数据可能是来自服务器的，那么我们就可以先将值请求下来，绑定到data返回的对象中，再通过v-bind来进行值的绑定，这个过程就是<strong>值绑定</strong>。 </p><p>这里不再给出具体的做法，因为还是v-bind的使用过程。</p><h3 id="5-8v-model修饰符-lazy"><a href="#5-8v-model修饰符-lazy" class="headerlink" title="5.8v-model修饰符 - lazy"></a>5.8<strong>v-model修饰符 - lazy</strong></h3><p><strong>问题：lazy修饰符是什么作用呢？</strong> </p><ul><li>默认情况下，v-model在进行双向绑定时，绑定的是input事件，那么会在每次内容输入后就将最新的值和绑定的属性进行同步；</li><li>如果我们在v-model后跟上lazy修饰符，那么会将绑定的事件切换为 change 事件，只有在提交时（比如回车）才会触发；</li></ul><img src="https://img-blog.csdnimg.cn/d54c822f7731432bb5ad3d6e06f9019d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="24" style="zoom:50%;" /><h3 id="5-9v-model修饰符-number"><a href="#5-9v-model修饰符-number" class="headerlink" title="5.9v-model修饰符 - number"></a>5.9<strong>v-model修饰符 - number</strong></h3><p>我们先来看一下v-model绑定后的值是什么类型的： </p><ul><li>message总是string类型，即使在我们设置type为number也是string类型；</li></ul> <img src="https://img-blog.csdnimg.cn/e26049742df2457da55084bec81606be.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="25" style="zoom:50%;" /><ul><li>如果我们希望转换为数字类型，那么可以使用 .number 修饰符：</li></ul> <img src="https://img-blog.csdnimg.cn/3128b87037654328895d5e29946c804d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="26" style="zoom:67%;" /><p>另外，在我们进行逻辑判断时，如果是一个string类型，在可以转化的情况下会进行隐式转换的： </p><p> 下面的score在进行判断的过程中会进行隐式转化的；</p> <img src="https://img-blog.csdnimg.cn/5513599e07fa432696ca6387c9483c5a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="27" style="zoom:50%;" /><h3 id="5-10-v-model修饰符-trim"><a href="#5-10-v-model修饰符-trim" class="headerlink" title="5.10 v-model修饰符 - trim"></a><strong>5.10 v-model修饰符 - trim</strong></h3><p>如果要自动过滤用户输入的守卫空白字符，可以给v-model添加 trim 修饰符：</p><img src="https://img-blog.csdnimg.cn/1c3a19c7ac8440568f075bb3756c0623.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16" alt="28" style="zoom:50%;" />]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-复杂data的处理方式&quot;&gt;&lt;a href=&quot;#1-复杂data的处理方式&quot; class=&quot;headerlink&quot; title=&quot;1. 复杂data的处理方式&quot;&gt;&lt;/a&gt;1. 复杂data的处理方式&lt;/h2&gt;&lt;p&gt;我们知道，在模板中可以直接通过&lt;strong&gt;插</summary>
      
    
    
    
    
    <category term="Vue3" scheme="http://sang63.github.io/tags/Vue3/"/>
    
  </entry>
  
  <entry>
    <title>小程序API（二）</title>
    <link href="http://sang63.github.io/2022/03/16/%E5%B0%8F%E7%A8%8B%E5%BA%8FAPI%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://sang63.github.io/2022/03/16/%E5%B0%8F%E7%A8%8B%E5%BA%8FAPI%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-03-16T08:59:37.000Z</published>
    <updated>2022-03-16T08:59:37.966Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title>小程序API</title>
    <link href="http://sang63.github.io/2022/02/15/%E5%B0%8F%E7%A8%8B%E5%BA%8FAPI/"/>
    <id>http://sang63.github.io/2022/02/15/%E5%B0%8F%E7%A8%8B%E5%BA%8FAPI/</id>
    <published>2022-02-15T03:46:52.000Z</published>
    <updated>2022-03-15T03:48:03.776Z</updated>
    
    <content type="html"><![CDATA[<p>小程序API</p><p>1.监听加速度变化时间的API函数wx.onAccelerometerChange(function callback)</p><p>（1）该函数用于监听加速度变化时间，其参数function callback为加速度变化时间的回调函数，该回调参数Object res的属性如表1-1所示。监听频率根据函数wx.onAccelerometerChange(Object object)的参数object.intreval来决定。</p><center>表1-1 函数wx.onAccelerometerChange(function callback)的回调函数的参数属性说明</center><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">x</td><td align="center">number</td><td align="center">X轴</td></tr><tr><td align="center">y</td><td align="center">number</td><td align="center">Y轴</td></tr><tr><td align="center">z</td><td align="center">number</td><td align="center">Z轴</td></tr></tbody></table><p>（2）函数wx.startAccelerometerChange(Object object)用于开始监听加速度数据，参数Object object的属性如表1-2所示。</p><center>表1-2 函数wx.startAccelerometerChange(Object object)的参数属性说明</center><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">默认值</th><th align="center">必填</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">interval</td><td align="center">string</td><td align="center">normal</td><td align="center">否</td><td align="center">监听加速度数据的频率</td></tr><tr><td align="center">success</td><td align="center">function</td><td align="center"></td><td align="center">否</td><td align="center">接口调用成功的回调函数</td></tr><tr><td align="center">fail</td><td align="center">function</td><td align="center"></td><td align="center">否</td><td align="center">接口调用失败的回调函数</td></tr><tr><td align="center">complete</td><td align="center">function</td><td align="center"></td><td align="center">否</td><td align="center">接口调用结束的回调函数（调用成功失败都会执行）</td></tr></tbody></table><p>（3）object.interval的合法值如表1-3所示。</p><center>表1-3 object.interval的合法值</center><table><thead><tr><th align="center">值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">game</td><td align="center">适用于更新游戏的回调频率，在20ms&#x2F;次左右</td></tr><tr><td align="center">ui</td><td align="center">适用于更新ui的回调频率，在60ms&#x2F;次左右</td></tr><tr><td align="center">normal</td><td align="center">普通的回调频率，在200ms&#x2F;次左右</td></tr></tbody></table><p>（4）函数wx.stopAccelerometerChange(Object object)用于停止监听加速度数据，参数Object object的属性只包括success，fail和complete三个回调函数。</p><p>2.API函数CanvasContext wx.createCanvasContext(string canvasId,Object this)。</p><p>用于创建canvas的绘图上下文CanvasContext对象，参数string canvasId是指要获取上下文的canvas组件，Object this是指在自定义组件下，当前组件的实例的this，表示在这个自定义组件下查找拥有canvas-id的canvas，如果省略则不在任何自定义组件中查找，返回值为CanvasContext的对象。</p><p>3.CanvasContext 对象用于绘图和设置图形样式</p><p>其常用属性如表3-1所示</p><center>表3-1 CanvasContext 对象常用属性</center><table><thead><tr><th align="center">属性类型</th><th align="center">属性</th><th align="center">属性说明</th></tr></thead><tbody><tr><td align="center">string</td><td align="center">fillStyle</td><td align="center">填充颜色。用法同CanvasContext.setFillStyle（）</td></tr><tr><td align="center">string</td><td align="center">strokeStyle</td><td align="center">边框颜色。用法同CanvasContext.setFillStyle（）</td></tr><tr><td align="center">number</td><td align="center">shadowOffsetX</td><td align="center">阴影相对于形状在水平方向上的偏移</td></tr><tr><td align="center">number</td><td align="center">shadowOffsetY</td><td align="center">阴影相对于形状在垂直方向上的偏移</td></tr><tr><td align="center">number</td><td align="center">shadowColor</td><td align="center">阴影的颜色</td></tr><tr><td align="center">number</td><td align="center">shadowBlur</td><td align="center">阴影的模糊级别</td></tr><tr><td align="center">number</td><td align="center">lineWidth</td><td align="center">线条的宽度。用法同CanvasContext.LineWidth（）</td></tr><tr><td align="center">number</td><td align="center">lineCap</td><td align="center">线条的端点样式。用法同CanvasContext.LineCap（）</td></tr><tr><td align="center">number</td><td align="center">lineJoin</td><td align="center">线条的交点样式。用法同CanvasContext.LineJoin（）</td></tr><tr><td align="center">number</td><td align="center">miterLimit</td><td align="center">最大斜接长度。用法同CanvasContext.setMiterLimit（）</td></tr><tr><td align="center">number</td><td align="center">lneDashOffset</td><td align="center">虚线偏移量，初始值是0</td></tr><tr><td align="center">string</td><td align="center">font</td><td align="center">当前字体样式的属性。符合CSSfont语法的DOMString字符串，至少需要提供字体大小和字体族名。默认值是10px</td></tr><tr><td align="center">number</td><td align="center">globalApha</td><td align="center">全局画笔透明度。范围为0-1，0为完全透明，1为完全不透明</td></tr><tr><td align="center">string</td><td align="center">globalCompositeOperation</td><td align="center">在绘制新图形时应用的合成操作的类型。目前安卓版只适用于fill填充块的合成，用于stroke线段的合成效果都是source-over</td></tr></tbody></table><p>4.CanvasContext 对象常用方法</p><p>(1) CanvasContext.draw(boolean reserve, function callback)。将之前在绘图上下文中的描述（路径、变形、样式）画到 canvas 中。</p><p>(2)CanvasGradient CanvasContext.createLinearGradient(number xo, number yo,number x1,number y1)。创建一个线性的渐变颜色。返回的 CanvasGradient对象需要使用CanvasGradient.addColorStop() 来指定渐变点，至少要两个。</p><p>(3)CanvasGradient CanvasContext.creatcCircularGradient(number x, number y, numberr)。创建一个圆形的渐变颜色。起点在圆心，终点在圆环。返回的 CanvasGradient 对象需要使用 CanvasGradient.addColorStop0 来指定渐变点，室少要两个。</p><p>(4)CanvasContext.createPattern(string image, string tepetition)。对指定的图像创建模式的方法，可在指定的方向上重复源图像。</p><p>(5)Object CanvasContext.measureText(string text)。测量文本尺寸信息，目前仅返回文本宽度，同步接口。</p><p>(6)CanvasContext.save()。保存绘图上下文。</p><p>(7)CanvasContext.restore()。恢复之前保存的绘图上下文。</p><p>(8)CanvasContext.beginPath()。开始创建一个路径。需要调用 fill或者 stroke 才会使用路径进行填充或描边在最开始的时候相当于调用了一次 beginPath。同一个路径内的多次setFillStyle、setStrokeStyle、setLineWidth 等设置，以最后一次设置为准。</p><p>(9)CanvasContext.moveTo(number x, number y)。把路径移动到画布中的指定点，不创建线条，用 stroke 方法来画线条。</p><p>(10)CanvasContext.lineTo(number x, number y)。增加一个新点，然后创建一条从上次指定点到目标点的线，用 stroke 方法来画线条。</p><p>(11)CanvasContext.quadraticCurveTo(number cpx, number cpy, number x, number y)。创建二次贝塞尔曲线路径，曲线的起始点为路径中前一个点。</p><p>(12)CanvasContext.bezierCurveTo()。创建二次贝塞尔曲线路径，曲线的起始点为路径前一个点。</p><p>(13)CanvasContext.arc(number x, number y, number r, number sAngle, number eAngle,plean counterclockwise)。创建一条弧线，创建一个圆可以指定起始弧度为 0，终止弧度为 2*Math.PI,用 stroke 或者 fill 方法来在 canvas 中画弧线。</p><p>(14) CanvasContext.rect(number x, number y, number width, number height)。矩形路径，需要用 fill 或者 stroke 方法将矩形真正画到 canvas 中。</p><p>(15)CanvasContext.arcTo(number x1, number y1, number x2, number y2, number radius)。根据控制点和半径绘制圆弧路径。</p><p>(16)CanvasContext.clip()。从原始画布中剪切任意形状和尺寸。一旦剪切了某个区域。则所有之后的绘图都会被限制在被剪切的区域内（不能访问画布上的其他区域）。可以在使用 clip 方法前通过使用 save 方法对当前画布区域进行保存，并在以后的任意时间通过 restore方法对其进行恢复。</p><p>(17)CanvasContext.fillRect(number x, number y, number width, number height)。填充一个矩形，用 setFillStyle 设置矩形的填充色，如果没设置默认是黑色。</p><p>(18) CanvasContext.strokeRect(number x, number y, number width, number height)。画一个矩形（非填充），用 setStrokeStyle 设置矩形线条的颜色，如果没设置默认是黑色。(19)CanvasContext.clearRect(number x, number y, number width, number height)。清除画布上在该矩形区域内的内容。(20)CanvasContext.fill()。对当前路径中的内容进行填充，默认的填充色为黑色。</p><p>(21)CanvasContext.stroke()。画出当前路径的边框，默认颜色为黑色。</p><p>(22)CanvasContext.closePath()。关闭一个路径，会连接起点和终点。如果关闭路径后没有调用 6ill 或者 stroke 并开启了新的路径，那之前的路径将不会被渲染。</p><p>(23)CanvasContext.scale(number scaleWidth, number scaleHeight)。在调用后，之后创建的路径其横纵坐标会被缩放，多次调用倍数会相乘。</p><p>(24）CanvasContext.rotate(number rotate)。以原点为中心顺时针旋转当前坐标轴，多次调用旋转的角度会叠加，原点可以用 translate 方法修改。</p><p>(25)CanvasContext.translate(number x, number y)。对当前坐标系的原点(0,0)进行变换，默认的坐标系原点为页面左上角。</p><p>(26)CanvasContext.drawImage(string imageResource, number sx, number sy, number sWidth,number sHeight, number dx, number dy, number dWidth, number dHeight)。绘制图像到画布。</p><p>(27)CanvasContext.strokeText(string text, number x, number y, number maxWidth)。给定的(x,y)位置绘制文本描边的方法。</p><p>(28)CanvasContext.transform(number scaleX, number scaleY, number skewX, number skewY, number translateX, number translateY)。使用矩阵多次叠加当前变换的方法。</p><p>(29) CanvasContext.setTransform(number scaleX, number scaleY, number skewX, numberskewY, number translateX, number translateY)。使用矩阵重新设置（覆盖）当前变换的方法。</p><p>(30)CanvasContext.setFillStyle(Color color)。设置填充色。</p><p>(31)CanvasContext.setStrokeStyle(Color color)。设置描边颜色。</p><p>(32)CanvasContext.setShadow(number offetX, number offetY, number blur, stringcolor)。设置阴影样式。</p><p>(33)CanvasContext.setGlobalAlpha(number alpha)。设置全局画笔透明度。</p><p>(34)CanvasContext,setLineWidth(number lineWidth)。设置线条的宽度。</p><p>(35)CanvasContext.setLineJoin(string lineJoin)。设置线条的交点样式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;小程序API&lt;/p&gt;
&lt;p&gt;1.监听加速度变化时间的API函数wx.onAccelerometerChange(function callback)&lt;/p&gt;
&lt;p&gt;（1）该函数用于监听加速度变化时间，其参数function callback为加速度变化时间的回调函数，该回调</summary>
      
    
    
    
    
    <category term="微信小程序" scheme="http://sang63.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>小程序组件（一）</title>
    <link href="http://sang63.github.io/2022/01/29/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://sang63.github.io/2022/01/29/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BB%84%E4%BB%B6%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-01-29T10:53:17.000Z</published>
    <updated>2022-03-09T10:15:08.067Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1.知识点"></a>1.知识点</h2><p>（1）利用正则表达式验证邮箱的方法。</p><p>（2）模态对话框API函数wx.showModal(Object object)的使用方法。</p><p>（3）页面跳转API函数wx.navigateTo(Object object)的使用方法。</p><p>（4）form、input、button等组件的使用方法。</p><h2 id="2-相关知识总结"><a href="#2-相关知识总结" class="headerlink" title="2.相关知识总结"></a>2.相关知识总结</h2><h3 id="2-1正则表达式"><a href="#2-1正则表达式" class="headerlink" title="2.1正则表达式"></a>2.1正则表达式</h3><p>2.1.1正则表达式由一些普通字符和一些元字符组成。普通字符包括大小写字母和数字，而元字符则具有特殊含义。正则表达式常用元字符含义如表2.1所示。</p><center>表 2.1  正则表达式常用元字符含义</center><table><thead><tr><th align="center">元字符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">\</td><td align="center">转义字符标识符</td></tr><tr><td align="center">^</td><td align="center">匹配输入字行首。如果设置了RegExp对象的Multiline属性，^也匹配“\n”或“\r”之后的位置</td></tr><tr><td align="center">$</td><td align="center">匹配输入行尾。如果设置了RegExp对象的Multiline属性，$也匹配“\n”或“\r”之前的位置</td></tr><tr><td align="center">*</td><td align="center">匹配前面的子表达式任意次。例如，zo*能匹配“z”，也能匹配“zo”以及“zoo”。等价于{0，}</td></tr><tr><td align="center">+</td><td align="center">匹配前面的子表达式一次或多次（大于等于1次）</td></tr><tr><td align="center">？</td><td align="center">匹配前面的子表达式零次或一次。例如，“do(es)?”可以匹配“do”或“does”。等价于{0，1}</td></tr><tr><td align="center">{n}</td><td align="center">n是一个非负整数。匹配确定的n次。例如，“o{2}”不能匹配“Bob”中的“o”，但是能匹配“food”中的两个o</td></tr><tr><td align="center">{n,m}</td><td align="center">m和n均为非负整数，其中n&lt;&#x3D;m。最少匹配n次且最多匹配m次</td></tr><tr><td align="center">[a-z]</td><td align="center">字符范围。匹配指定范围内的任意字符。例如，[a-z]可以匹配“a”到“z”范围内的任意小写字母字符。注意：只有连字符在字符组内部时，并且出现在两个字符之间时，才能表示字符的范围；如果出现在字符组的开头，则只能表示连字符本身</td></tr><tr><td align="center">[^a-z]</td><td align="center">负值字符范围。匹配任何不在指定范围内的任意字符。例如，【^a-z】可以匹配任何不在“a”到“z”范围内的任意字符</td></tr><tr><td align="center">\d</td><td align="center">匹配一个数字字符。等价于[0-9]。grep要加上-P，perl正则支持</td></tr><tr><td align="center">\D</td><td align="center">匹配一个非数字字符。等价于【^0-9】。grep要加上-P，perl正则支持</td></tr><tr><td align="center">\s</td><td align="center">匹配任何不可见字符，包括空格、制表符、换页符等。等价于[\f\n\r\t\v]</td></tr><tr><td align="center">\S</td><td align="center">匹配任何可见字符。等价于【^\f\n\r\t\v】</td></tr><tr><td align="center">\w</td><td align="center">匹配包括下划线的任何单词字符。类似但不等价于“[A-Za-z0-9_]”，这里的“单词”字符使用Unicode字符集</td></tr><tr><td align="center">\W</td><td align="center">匹配任何非单词字符。等价于“【^A-Za-z0-9_】”</td></tr></tbody></table><p>2.1.2利用正则表达式验证电子邮箱。如下正则表达式的含义：</p><blockquote><p>&#x2F;^[a-zA-Z0-9_.-]+@[a-zA-Z0-9-]+(.[a-zA-Z0-9-]+)*.[a-zA-Z0-9]{2,6}$&#x2F;</p></blockquote><pre><code>（1）正则表达式以符号/^开始，以符号$/结束。（2）@之前的表达式[a-zA-Z0-9_.-]+表示字符串必须由1个及1个以上的大小写字母、数字、下划线、点或横杠组成，+号表示前面字符出现次数必须大于或等于1.（3）@之后的表达式[a-zA-Z0-9-]+表示字符串必须由1个及1个以上的大小的大小写字母、数字或横杠组成。（4）(\.[a-zA-Z0-9-]+)*表示后面字符串第一个字符必须是点，点后面字符串必须由1个及1个以上的大小写字母、数字或横杠组成。*表示匹配前面的子表达式任意次。（5）\\.[a-zA-Z0-9]&#123;2,6&#125;表示最后一个表达式由2~6个字母或数字构成。</code></pre><h3 id="2-2显示模态对话框的API函数wx-showModal（Object-object）"><a href="#2-2显示模态对话框的API函数wx-showModal（Object-object）" class="headerlink" title="2.2显示模态对话框的API函数wx.showModal（Object object）"></a>2.2显示模态对话框的API函数wx.showModal（Object object）</h3><p>模态对话框与非模态对话框的区别是：模态对话框显示时不能操作该应用程序的其他窗口界面，而非模态对话框显示时可以操作该应用程序的其他窗口界面。显示模态对话框的API函数参数属性表如表2.2所示。</p><center>表 2.2  API函数wx.showModal（Object object）的参数属性说明</center><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">默认值</th><th align="center">必填</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">title</td><td align="center">string</td><td align="center"></td><td align="center">是</td><td align="center">提示的标题</td></tr><tr><td align="center">content</td><td align="center">string</td><td align="center"></td><td align="center">是</td><td align="center">提示的内容</td></tr><tr><td align="center">showCancel</td><td align="center">boolean</td><td align="center">TRUE</td><td align="center">否</td><td align="center">是否显示“取消”按钮</td></tr><tr><td align="center">cancelText</td><td align="center">string</td><td align="center">‘取消’</td><td align="center">否</td><td align="center">“取消”按钮的文字，最多4个字符</td></tr><tr><td align="center">cancelColor</td><td align="center">string</td><td align="center">#000000</td><td align="center">否</td><td align="center">“取消”按钮的文字颜色，必须是十六进制格式的颜色字符串</td></tr><tr><td align="center">confireText</td><td align="center">string</td><td align="center">‘确定’</td><td align="center">否</td><td align="center">“确定”按钮的文字，最多4个字符</td></tr><tr><td align="center">confirmColor</td><td align="center">string</td><td align="center">#576B95</td><td align="center">否</td><td align="center">“确定”按钮的文字颜色，必须是十六进制格式的颜色字符串</td></tr><tr><td align="center">success</td><td align="center">function</td><td align="center"></td><td align="center">否</td><td align="center">接口调用成功的回调函数</td></tr><tr><td align="center">fail</td><td align="center">function</td><td align="center"></td><td align="center">否</td><td align="center">接口调用失败的回调函数</td></tr><tr><td align="center">complete</td><td align="center">function</td><td align="center"></td><td align="center">否</td><td align="center">接口调用结束的回调函数（调用成功、失败都会执行）</td></tr></tbody></table><p>object.success(Object res)回调函数的参数Object res的属性如下表2.3所示。</p><center>表 2.3  object.success回调函数参数object res的属性</center><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">confirm</td><td align="center">boolean</td><td align="center">为TRUE时，表示用户点击了“确定”按钮</td></tr><tr><td align="center">cancel</td><td align="center">boolean</td><td align="center">为TRUE时，表示用户点击了“取消”按钮（用于Android系统区分点击蒙层关闭还是点击“取消”按钮关闭）</td></tr></tbody></table><h3 id="2-3页面跳转API函数wx-navigateTo-Object-object"><a href="#2-3页面跳转API函数wx-navigateTo-Object-object" class="headerlink" title="2.3页面跳转API函数wx.navigateTo(Object object)"></a>2.3页面跳转API函数wx.navigateTo(Object object)</h3><p>保留当前页面，跳转到应用内的某个页面，但是不能跳转到tabBar页面。使用wx.navigateBack可以返回到原页面。小程序中页面最多10层。参数Object object的属性出success、fail和complete三个回调函数外，还有一个string类型的必填属性url，表示需要跳转的应用内非tabBar的页面的路径，路径后可以带参数。</p><h3 id="2-4form表单"><a href="#2-4form表单" class="headerlink" title="2.4form表单"></a>2.4form表单</h3><p>form表单组件用于将用户在其内部组件switch、input、checkbox、silder、picker内输入的内容提交。当点击form表单的form-type为submit的button组件时，会将表单组件中的value值进行提交，需要在表单内各组件中加上name来区分不同组件的value。form组件常用属性说明如下表2.4所示。</p><center>表 2.4  form组件常用属性说明</center><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">必填</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">bindsubmit</td><td align="center">eventhandle</td><td align="center">否</td><td align="center">携带form中的数据触发submit事件，event.detail&#x3D;{value:{‘name’:’value’},formId:’’}</td></tr><tr><td align="center">bindreset</td><td align="center">eventhandle</td><td align="center">否</td><td align="center">表单重置时会触发reset事件</td></tr></tbody></table><h3 id="2-5picker选择器组件"><a href="#2-5picker选择器组件" class="headerlink" title="2.5picker选择器组件"></a>2.5picker选择器组件</h3><p>2.5.1picker组件是从屏幕底部弹起的滚动选择器，现支持5中类型的选择器，通过mode来区分，分别是：普通选择器、多列选择器、时间选择器、日期选择器、省市选择器，默认的是普通选择器。各种类型picker组件的属性说明如下表2.5~2.9所示。</p><center>表 2.5  普通选择器(mode=selector)的属性说明</center><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">默认值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">range</td><td align="center">array&#x2F;object array</td><td align="center">[]</td><td align="center">mode为selector或multiSelector时，range有效</td></tr><tr><td align="center">range-key</td><td align="center">string</td><td align="center"></td><td align="center">当range是一个object array时，通过range-key来指定Object中key的值作为选择器显示内容</td></tr><tr><td align="center">value</td><td align="center">number</td><td align="center">0</td><td align="center">value的值表示选择了range中的第几个（下标从0开始）</td></tr><tr><td align="center">bindchange</td><td align="center">eventHandle</td><td align="center"></td><td align="center">value改变时触发change事件，event.detail&#x3D;{value:value}</td></tr></tbody></table><center>表 2.6  多列选择器(mode=multiSelector)的属性说明</center><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">默认值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">range</td><td align="center">二维array&#x2F;二维object array</td><td align="center">[]</td><td align="center">mode为selector或multiSelector时，range有效。二维数组，长度表示多少列，数组的每项表示每列的数据，如[[“a”,”b”],[“c”,”d”]]</td></tr><tr><td align="center">range-key</td><td align="center">string</td><td align="center"></td><td align="center">当range是一个object array时，通过二维range-key来指定Object中key的值作为选择器显示内容</td></tr><tr><td align="center">value</td><td align="center">array</td><td align="center">[]</td><td align="center">value每一项的值表示选择了range中的第几个（下标从0开始）</td></tr><tr><td align="center">bindchange</td><td align="center">eventhandle</td><td align="center"></td><td align="center">value改变时触发change事件，event.detail&#x3D;{value:value}</td></tr><tr><td align="center">bindcolumnchange</td><td align="center">eventhandle</td><td align="center"></td><td align="center">某一列的值改变时触发，columnchange事件，event.detail&#x3D;{column:column,value:value}，column的值表示改变了第几列（下标从0开始），value的值表示变更值的下标</td></tr></tbody></table><center>表 2.7  时间选择器(mode=time)的属性说明</center><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">默认值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">string</td><td align="center"></td><td align="center">表示选中的时间，格式为”hh:mm”</td></tr><tr><td align="center">start</td><td align="center">string</td><td align="center"></td><td align="center">表示有效时间范围的开始，字符串格式为”hh:mm”</td></tr><tr><td align="center">end</td><td align="center">string</td><td align="center"></td><td align="center">表示有效时间范围的结束，字符串格式为”hh:mm”</td></tr><tr><td align="center">bindchange</td><td align="center">eventhandle</td><td align="center"></td><td align="center">value改变时触发change事件，event.detail&#x3D;{value:value}</td></tr></tbody></table><center>表 2.8  日期选择器(mode=date)的属性说明</center><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">默认值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">string</td><td align="center">0</td><td align="center">表示选中的日期，格式为”YYYY-MM-DD”</td></tr><tr><td align="center">start</td><td align="center">string</td><td align="center"></td><td align="center">表示有效日期范围的开始，字符串格式为”YYYY-MM-DD”</td></tr><tr><td align="center">end</td><td align="center">string</td><td align="center"></td><td align="center">表示有效日期范围的结束，字符串格式为”YYYY-MM-DD”</td></tr><tr><td align="center">fields</td><td align="center">string</td><td align="center">day</td><td align="center">有效值year，month，day，表示选择器的粒度</td></tr><tr><td align="center">bindchange</td><td align="center">eventhandle</td><td align="center"></td><td align="center">value改变时触发change事件，event.detail&#x3D;{value:value}</td></tr></tbody></table><center>表 2.9  省市选择器(mode=region)的属性说明</center><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">默认值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">array</td><td align="center">[]</td><td align="center">表示选中的省市区，默认选中每一列的第一个值</td></tr><tr><td align="center">custom-item</td><td align="center">string</td><td align="center"></td><td align="center">可为每一列的顶部添加一个自定义的项</td></tr><tr><td align="center">bindchange</td><td align="center">eventhandle</td><td align="center"></td><td align="center">value改变时触发change事件，event.detail&#x3D;{value:value,code:code,postcode:postcode}，其中字段code时统计用区划代码，postcode时邮政编码</td></tr></tbody></table><h2 id="3-案例分析"><a href="#3-案例分析" class="headerlink" title="3.案例分析"></a>3.案例分析</h2><h3 id="3-1案例描述"><a href="#3-1案例描述" class="headerlink" title="3.1案例描述"></a>3.1案例描述</h3><p>编写一个考生选择考试场次的小程序，考生首先利用邮箱和密码登录，输入自己的姓名和学号后选择考试场次。考生登陆时需要进行邮箱和密码认证，如果某项输入为空，或者邮箱填写不正确，或者输入的密码和确认密码不一致，将给出错误提示并要求重新填写。</p><h3 id="3-2实现效果"><a href="#3-2实现效果" class="headerlink" title="3.2实现效果"></a>3.2实现效果</h3><p>根据案例描述可以做出如下图所示的效果。</p><p>（1）在没有输入邮箱或密码情况下点击“登录”按钮，则会出现如图01所示的界面，在此时界面下方给出了“邮箱或密码不得为空！”的提示。</p><p><img src="https://img-blog.csdnimg.cn/68231b9f3314488a8f19bca798b55c8f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_19,color_FFFFFF,t_70,g_se,x_16" alt="01"></p><p>（2）输入邮箱地址时，邮箱地址input组件的边框颜色发生变化，如果邮箱格式输入不正确，则在输入完成时会显示“邮箱格式错误”的提示。</p><p>（3）输入密码时，如果两次输入的密码不一致，点击“登录”按钮会给出“两次输入密码不一致”的提示，如图02所示。</p><p><img src="https://img-blog.csdnimg.cn/2220e32b3e76441885d0d2ed453fbb0f.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_19,color_FFFFFF,t_70,g_se,x_16" alt="02"></p><p>（4)如果邮箱和密码都正确，点击“登录”将进入”考试时段选择”界面，此时姓名input组建将自动获得焦点，输入完姓名和学号后，当点击“请选择考试时段：”文本时，在屏幕下方弹出三个场次的时间段，如图03所示。</p><p><img src="https://img-blog.csdnimg.cn/39528256701f4f4599affd3f9f71b22b.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_19,color_FFFFFF,t_70,g_se,x_16" alt="03"></p><p>（5）所有信息输入和选择完成后点击“确定”按钮，此时将弹出“确认信息”对话框，如图04所示，如果信息无误点击“确认”按钮，此时出现“信息确认”对话框“如果信息不正确点击”取消“按钮可以重新填写。</p><p><img src="https://img-blog.csdnimg.cn/264b021eb2f5404780374c0f74ee5523.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_19,color_FFFFFF,t_70,g_se,x_16" alt="04"></p><h3 id="3-3案例实现"><a href="#3-3案例实现" class="headerlink" title="3.3案例实现"></a>3.3案例实现</h3><p>3.3.1编写index.wxml文件代码</p><p>（1）在form组件中利用text组建和input组件实现电子邮件、密码和确认密码的输入提示及输入，后面放置1个button登录按钮实现form组建的提交事件，按钮后main防治了2个view组件用来显示当邮箱或密码与确认密码不一致是的错误提示。</p><p>（2）代码中的事件绑定处理函数由2个：form组件提交事件绑定函数formSubmit和input组件输入变化事件绑定函数inputemail，这两个函数都在input.js文件中进行定义。</p><p>（3）代码中主要使用了8种样式：page，.hr，.lineLayout，text，input，input：hover，button，.txt。</p><pre><code>&lt;!--index.wxml--&gt;&lt;view class=&quot;box&quot;&gt;  &lt;view class=&quot;title&quot;&gt;考试场次选择&lt;/view&gt;  &lt;view class=&quot;hr&quot;&gt;&lt;/view&gt;  &lt;form bindsubmit=&quot;formSubmit&quot;&gt;    &lt;view class=&quot;lineLayout&quot;&gt;      &lt;text&gt;电子邮箱：&lt;/text&gt;      &lt;input type=&quot;text&quot; bindchange=&quot;inputemail&quot; name=&quot;email&quot; value=&quot;&#123;&#123;getEmail&#125;&#125;&quot; placeholder=&quot;请输入电子邮箱&quot; /&gt;    &lt;/view&gt;    &lt;view class=&quot;lineLayout&quot;&gt;      &lt;text&gt;输入密码：&lt;/text&gt;      &lt;input type=&quot;password&quot; name=&quot;password&quot; value=&quot;&#123;&#123;getPwd&#125;&#125;&quot; placeholder=&quot;请输入密码&quot; /&gt;    &lt;/view&gt;    &lt;view class=&quot;lineLayout&quot;&gt;      &lt;text&gt;确认密码：&lt;/text&gt;      &lt;input type=&quot;password&quot; name=&quot;confirm&quot; value=&quot;&#123;&#123;getPwdConfirm&#125;&#125;&quot; placeholder=&quot;请再次输入密码&quot; /&gt;    &lt;/view&gt;    &lt;view&gt;      &lt;button type=&quot;primary&quot; form-type=&quot;submit&quot;&gt;登录&lt;/button&gt;    &lt;/view&gt;    &lt;view&gt;      &lt;view class=&quot;txt&quot;&gt;&#123;&#123;showMsg01&#125;&#125;&lt;/view&gt;      &lt;view class=&quot;txt&quot;&gt;&#123;&#123;showMsg02&#125;&#125;&lt;/view&gt;    &lt;/view&gt;  &lt;/form&gt;&lt;/view&gt;</code></pre><p>3.3.2编写index.wxss文件代码</p><pre><code>/**index.wxss**/.lineLayout&#123;  display: inline-block;  margin: 10px;&#125;.hr&#123;  height: 2px;  background-color: greenyellow;  margin: 10px 0;&#125;.text&#123;  float: left;&#125;input&#123;  width: 180px;  height: 30px;  border-bottom: 2px solid silver;  float: right;&#125;input:hover&#123;  border-bottom: 2px solid chocolate;&#125;button&#123;  width: 150px;  margin: 20px auto;&#125;page&#123;  height: 100%;  background: gainsboro;&#125;.txt&#123;  color: red;  background: yellow;&#125;</code></pre><p>3.3.3编写index.js文件代码</p><p>代码主要定义了3个函数：formSubmit，inputemail和checkEmail。</p><p>（1）form组件提交事件函数formSubmit。当点击form组件中的提交按钮后引发该事件。函数首先根据从邮箱和密码输入框中获取的字符串长度e.detail.value.email.length和e.detail.value.password.length判断输入的数据是否为空，如果为空给出错误提示，否则再判断密码和确认密码是否一致，如果不一致给出错误提示并清空两个输入框中的内容，如果一致则让页面跳转带detail页面。</p><p>（2）邮件输入框输入变化函数inputemail。当输入框中输入的内容发生变化时引发该事件。函数首先获取邮件输入框中输入的值e.detail.value，然后调用自定义对象函数this.checkEmail（）判断输入的字符串是否符合邮箱格式要求。</p><p>（3）自定义对象函数checkEmail。首先将正则表达式邮箱验证字符串复制给变量str，然后调用字符串的test函数来验证在邮箱输入框中输入的字符串email是否符合正则表达式的要求，如果符合要求则返回ture，表示通过验证，否则调用信息框给出错误提示，清空邮件输入框内容并返回false，表示没有通过验证。</p><pre><code>// index.jsPage(&#123;  data: &#123;   getEmail:&#39;&#39;,   getPwd:&#39;&#39;,   getPwdConfirm:&#39;&#39;  &#125;,  formSubmit:function(e)&#123;                    //提交表单（点击“注册”按钮）事件    if(e.detail.value.email.length==0||e.detail.value.password.length==0)&#123;  //判断邮箱和密码输入框内容是否为空      this.setData(&#123;        showMsg01:&#39;邮箱或密码不得为空！&#39;      &#125;)    &#125;else if(e.detail.value.password != e.detail.value.confirm)&#123;      this.setData(&#123;        showMsg02:&#39;两次输入密码不一致！&#39;,        getPwd:&#39;&#39;,                         //清空输入框内容        getPwdConfirm:&#39;&#39;      &#125;)    &#125;else&#123;      wx.navigateTo(&#123;        url: &#39;../detail/detail&#39;,      &#125;)    &#125;  &#125;,  inputemail:function(e)&#123;    var email=e.detail.value    var checkedNum=this.checkEmail(email)  &#125;,  checkEmail:function(email)&#123;    let str=/^[a-zA-Z0-9_.-]+@[a-zA-Z0-9-]+(\.[a-zA-Z0-9-]+)*\.[a-zA-Z0-9]&#123;2,6&#125;$/    if(str.test(email))&#123;               //检查邮箱地址是否符合正则表达式要求      return true    &#125;else&#123;      wx.showToast(&#123;                  //显示消息提示框        title: &#39;邮箱格式错误&#39;,        icon:&#39;loading&#39;      &#125;)      this.setData(&#123;        getEmail:&#39;&#39;      &#125;)      return false    &#125;  &#125;&#125;)</code></pre><p>3.3.4在pages文件夹中创建detail文件夹，在其中添加4个文件，然后编写detail.wxml文件代码。该页面的主要功能是：用户输入姓名和学号，并选择考试时段。耶main主要利用form组件，input组件和picker组件来实现相应功能。</p><p>（1）文件代码绑定的事件处理函数包括：form组件提交事件函数formSubmit和picker组件选择变化事件函数chooseTime。这两个函数在detail.js文件中进行了定义。</p><p>（2）文件代码中使用的样式包括：page，.flex，input，input：hover，picker，.btnLayout和button。这些样式在detail.wxss文件中进行定义。</p><pre><code>&lt;!--pages/detail/detail.wxml--&gt;&lt;view class=&quot;box&quot;&gt;  &lt;view class=&quot;title&quot;&gt;考试时段选择&lt;/view&gt;  &lt;form bindsubmit=&quot;formSubmit&quot;&gt;    &lt;view class=&quot;flex&quot;&gt;      &lt;text&gt;姓名：&lt;/text&gt;      &lt;input type=&quot;text&quot; value=&quot;&#123;&#123;name&#125;&#125;&quot; name=&quot;name&quot; auto-focus /&gt;    &lt;/view&gt;    &lt;view class=&quot;flex&quot;&gt;      &lt;text&gt;学号：&lt;/text&gt;      &lt;input type=&quot;number&quot; value=&quot;&#123;&#123;id&#125;&#125;&quot; name=&quot;id&quot; /&gt;    &lt;/view&gt;    &lt;picker bindchange=&quot;chooseTime&quot; value=&quot;&#123;&#123;index&#125;&#125;&quot; range=&quot;&#123;&#123;array&#125;&#125;&quot; name=&quot;time&quot;&gt;请选择考试时段：&#123;&#123;array[index]&#125;&#125;&lt;/picker&gt;    &lt;view class=&quot;btnLayout&quot;&gt;      &lt;button type=&quot;primary&quot; form-type=&quot;submit&quot;&gt;确定&lt;/button&gt;      &lt;button type=&quot;primary&quot;&gt;取消&lt;/button&gt;    &lt;/view&gt;  &lt;/form&gt;&lt;/view&gt;</code></pre><p>3.3.5编写detail.wxss文件代码</p><pre><code>/* pages/detail/detail.wxss */page&#123;  height: 100%;  background: gainsboro;&#125;.flex&#123;  display: flex;  margin: 5px 0;  justify-content: flex-start;  align-items: center;&#125;.btnLayout&#123;  display: flex;  flex-direction: row;  justify-content: space-around;  margin: 50px 0;  width: 100%;&#125;input&#123;  width: 150px;  height: 30px;  border: 2px solid silver;  margin: 5px;&#125;input:hover&#123;  border: 2px solid chocolate;&#125;picker&#123;  margin: 10px;  padding-top: 10px;  padding-bottom: 10px;&#125;button&#123;  width: 80px;&#125;</code></pre><p>3.3.6编写detail.js文件代码</p><p>代码主要初始化了picker组件使用的数组array，定义了form组件提交事件函数formSubmit和picker组件选择变化事件函数chooseTime。</p><p>（1）array数组初始化。在打他中初始化了array数组。</p><p>（2）formSubmit函数。首先获取input组件中输入的姓名、学号以及picker组件的选项序号，然后调用wx.showModal（）模态对话框显示输入和选择的信息并给出正确的提示，如果点击“确定”按钮，则调用wx.showModal（）模态对话框显示确认信息，页面跳转到主页面；如果点击“取消”按钮，则在console中显示取消信息。</p><p>（3）chooseTime函数。用于获取选择的考试时间段，利用e.detail.value表达式可以获得选项的序号，在视图层根据序号找到相应的时间段。</p><pre><code>// pages/detail/detail.jsPage(&#123;  data: &#123;    array:[      &#39;第一场 15:00&#39;,      &#39;第二场 16:20&#39;,      &#39;第三场 17:40&#39;    ]  &#125;,  formSubmit:function(e)&#123;    var name=e.detail.value.name;         //获取姓名输入框内容    var id=e.detail.value.id;             //获取学号输入框内容    var time=e.detail.value.time;    wx.showModal(&#123;                       //显示模态对话框      title: &#39;确认信息&#39;,      content:e.detail.value.name+&quot;同学，你的学号是&quot;+e.detail.value.id+&quot;，你选择的场次是：&quot;+this.data.array[time]+&quot;，请确认信息！&quot;,      success:function(res)&#123;            //wx.shoeModal接口调用成功的回调函数        if(res.confirm)&#123;          wx.showModal(&#123;            title: &#39;信息确认&#39;,            content:&#39;你的考场信息已经确认！&#39;          &#125;)          wx.navigateTo(&#123;              //页面跳转            url: &#39;../index/index&#39;,          &#125;)        &#125;else&#123;          console.log(&#39;用户点击取消&#39;)        &#125;      &#125;    &#125;)  &#125;,  chooseTime:function(e)&#123;    var index=e.detail.value        //获得picker组件选项下标    this.setData(&#123;      index:index    &#125;)  &#125;&#125;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-知识点&quot;&gt;&lt;a href=&quot;#1-知识点&quot; class=&quot;headerlink&quot; title=&quot;1.知识点&quot;&gt;&lt;/a&gt;1.知识点&lt;/h2&gt;&lt;p&gt;（1）利用正则表达式验证邮箱的方法。&lt;/p&gt;
&lt;p&gt;（2）模态对话框API函数wx.showModal(Object</summary>
      
    
    
    
    
    <category term="微信小程序" scheme="http://sang63.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>小程序框架</title>
    <link href="http://sang63.github.io/2022/01/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/"/>
    <id>http://sang63.github.io/2022/01/24/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6/</id>
    <published>2022-01-24T12:21:19.000Z</published>
    <updated>2022-01-25T12:47:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、小程序的基本架构"><a href="#一、小程序的基本架构" class="headerlink" title="一、小程序的基本架构"></a>一、小程序的基本架构</h2><h2 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1.知识点"></a>1.知识点</h2><p>（1）小程序整体配置方法。</p><p>（2）小程序页面配置方法</p><h2 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2.实现方法"></a>2.实现方法</h2><h3 id="2-1全局配置"><a href="#2-1全局配置" class="headerlink" title="2.1全局配置"></a>2.1全局配置</h3><p>小程序根目录下的app.json文件夹用来对微信小程序进行全局配置，文件内容作为一个JSON对象，主要配置项如下表所示。</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">必填</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">pages</td><td align="center">string[]</td><td align="center">是</td><td align="center">页面路径列表</td></tr><tr><td align="center">window</td><td align="center">object</td><td align="center">否</td><td align="center">全局的默认窗口表现</td></tr><tr><td align="center">tabBar</td><td align="center">object</td><td align="center">否</td><td align="center">底部tab栏的表现</td></tr><tr><td align="center">networkTimeout</td><td align="center">object</td><td align="center">否</td><td align="center">网络超时时间</td></tr><tr><td align="center">debug</td><td align="center">boolean</td><td align="center">否</td><td align="center">是否开启debug模式，默认关闭</td></tr><tr><td align="center">permission</td><td align="center">object</td><td align="center">否</td><td align="center">小程序接口权限相关设置</td></tr></tbody></table><p>（1）pages用于指定小程序由哪些页面组成，每一项都对应一个页面的路径（含文件名）信息。文件名不需要写文件扩展名，框架会自动去寻找对应位置的.json，.js，.wxml，.wxss四个文件进行处理。数组的第一项代表小程序的初始页面（即首页）。小程序中新增&#x2F;减少页面，都需要对pages数组进行修改。如果开发目录如图01所示，则需要在app.json中写</p><pre><code>&#123;  &quot;pages&quot;: [    &quot;pages/index/index&quot;,    &quot;pages/logs/logs&quot;    ]&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/f4fe465908cf4fcaa33d9663f8b46ec8.png#pic_center" alt="01"></p><p>（2）window用于设置小程序的状态栏、导航条、标题、窗口背景色。其中涉及的及格属性如下表所示。</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">navigationBarBackgroundColor</td><td align="center">HeColor</td><td align="center">#000000</td><td align="center">导航栏背景颜色</td></tr><tr><td align="center">navigationBarTextStyle</td><td align="center">string</td><td align="center">white</td><td align="center">导航栏标题颜色，仅支持black&#x2F;white</td></tr><tr><td align="center">navigationBarTitleText</td><td align="center">string</td><td align="center"></td><td align="center">导航栏标题文字颜色</td></tr><tr><td align="center">navigationStyle</td><td align="center">string</td><td align="center">default</td><td align="center">导航栏样式</td></tr><tr><td align="center">backgroundColor</td><td align="center">HexColor</td><td align="center">#ffffff</td><td align="center">窗口的背景色</td></tr><tr><td align="center">backgroundTextStyle</td><td align="center">string</td><td align="center">dark</td><td align="center">下拉loading的样式，仅支持black&#x2F;white</td></tr><tr><td align="center">pageOrientation</td><td align="center">string</td><td align="center">portrait</td><td align="center">屏幕旋转设置，支持auto&#x2F;portrait&#x2F;landscape</td></tr></tbody></table><p>（3）tabBar用来配置小程序底部的tab。如果小程序是一个多tab应用（客户端 窗口的底部或顶部有tab栏可以切换页面），可以通过tabBar配置项指定tab栏的表现，以及tab切换时现实的对应页面。tabBar对象的常用属性如下表所示。</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">必选</th><th align="center">默认值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">color</td><td align="center">HexColor</td><td align="center">是</td><td align="center"></td><td align="center">tab上的文字默认颜色，仅支持十六进制颜色</td></tr><tr><td align="center">selectColor</td><td align="center">HexColor</td><td align="center">是</td><td align="center"></td><td align="center">tab上的文字选中时的颜色，仅支持十六进制颜色</td></tr><tr><td align="center">backgroundColor</td><td align="center">HexColor</td><td align="center">是</td><td align="center"></td><td align="center">tab的背景色，仅支持十六进制颜色</td></tr><tr><td align="center">borderStyle</td><td align="center">string</td><td align="center">否</td><td align="center">black</td><td align="center">tabBar上边框的颜色，仅支持black&#x2F;white</td></tr><tr><td align="center">list</td><td align="center">string</td><td align="center">是</td><td align="center"></td><td align="center">tab的列表，详见list属性说明，最少两个，最多五个</td></tr><tr><td align="center">position</td><td align="center">string</td><td align="center">否</td><td align="center">bottom</td><td align="center">tabBar的位置，仅支持bottom&#x2F;top</td></tr><tr><td align="center">custom</td><td align="center">boolean</td><td align="center">否</td><td align="center">FALSE</td><td align="center">自定义tabBar</td></tr></tbody></table><p>其中list接受一个数组，只能配置最少两个，最多五个tab。tab按数组的顺序排列，每个项都是一个对象，其属性值如下表所示。</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">必填</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">pagePath</td><td align="center">string</td><td align="center">是</td><td align="center">页面路径，必须在pages中定义</td></tr><tr><td align="center">text</td><td align="center">string</td><td align="center">是</td><td align="center">tab上按钮文字</td></tr><tr><td align="center">iconPath</td><td align="center">string</td><td align="center">否</td><td align="center">图片路径，icon大小限制40KB。当position为top时不显示icon</td></tr><tr><td align="center">selectIconPath</td><td align="center">string</td><td align="center">否</td><td align="center">选中时的图片路径，icon大小限制40KB。当position为top时不显示icon</td></tr></tbody></table><h3 id="2-2页面配置"><a href="#2-2页面配置" class="headerlink" title="2.2页面配置"></a>2.2页面配置</h3><p>每个小程序页面也可以使用同名.json文件来对本页面的窗口表现进行配置，页面中配置项会覆盖app.json的window中相同的配置项。</p><h2 id="3-案例分析"><a href="#3-案例分析" class="headerlink" title="3.案例分析"></a>3.案例分析</h2><h3 id="3-1案例描述"><a href="#3-1案例描述" class="headerlink" title="3.1案例描述"></a>3.1案例描述</h3><p>创建一个包含：首页、教学、科研、资讯和关于我们5个标签的小程序，每个标签都有对应的页面、图标和标签文字，点击某个标签的图标或文字都将切换到对应的页面，同时该标签的图标和文字颜色会发生相应的变化，页面的标题也发生相应的变化，而其他标签则变为非选中状态。</p><h3 id="3-2实现效果"><a href="#3-2实现效果" class="headerlink" title="3.2实现效果"></a>3.2实现效果</h3><p><img src="https://img-blog.csdnimg.cn/559364447ed040d4ac86de604150d80a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="02"></p><h3 id="3-3案例实现"><a href="#3-3案例实现" class="headerlink" title="3.3案例实现"></a>3.3案例实现</h3><p>（1）创建images文件夹，准备10个图片作为变穷选中和非选中状态下的图标，把这些图片放在images文件夹中，并把images文件夹复制到建立的工程文件夹中。</p><blockquote><p>推荐图标网站：<a href="https://design.maliquankai.com/">https://design.maliquankai.com/</a></p></blockquote><p>（2）编写app.json文件代码，定义五个页面：index，jiaoxue，keyan，zixun，guanyu。</p><pre><code>&#123;  &quot;pages&quot;: [    &quot;pages/index/index&quot;,    &quot;pages/jiaoxue/jiaoxue&quot;,    &quot;pages/keyan/keyan&quot;,    &quot;pages/zixun/zixun&quot;,    &quot;pages/guanyu/guanyu&quot;  ],  &quot;window&quot;: &#123;    &quot;backgroundTextStyle&quot;: &quot;light&quot;,    &quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;,    &quot;navigationBarTitleText&quot;: &quot;xxxx大学欢迎您&quot;,    &quot;navigationBarTextStyle&quot;: &quot;black&quot;  &#125;,  &quot;tabBar&quot;: &#123;    &quot;color&quot;: &quot;#000&quot;,    &quot;selectedColor&quot;: &quot;#00f&quot;,    &quot;list&quot;: [      &#123;        &quot;pagePath&quot;: &quot;pages/index/index&quot;,        &quot;text&quot;: &quot;首页&quot;,        &quot;iconPath&quot;: &quot;/images/home.png&quot;,        &quot;selectedIconPath&quot;: &quot;/images/home-fill.png&quot;      &#125;,      &#123;        &quot;pagePath&quot;: &quot;pages/jiaoxue/jiaoxue&quot;,        &quot;text&quot;: &quot;教学&quot;,        &quot;iconPath&quot;: &quot;/images/all.png&quot;,        &quot;selectedIconPath&quot;: &quot;/images/all-fill.png&quot;      &#125;,      &#123;        &quot;pagePath&quot;: &quot;pages/keyan/keyan&quot;,        &quot;text&quot;: &quot;科研&quot;,        &quot;iconPath&quot;: &quot;/images/set (1).png&quot;,        &quot;selectedIconPath&quot;: &quot;/images/set.png&quot;      &#125;,      &#123;        &quot;pagePath&quot;: &quot;pages/zixun/zixun&quot;,        &quot;text&quot;: &quot;资讯&quot;,        &quot;iconPath&quot;: &quot;/images/folder.png&quot;,        &quot;selectedIconPath&quot;: &quot;/images/folder-fill.png&quot;      &#125;,      &#123;        &quot;pagePath&quot;: &quot;pages/guanyu/guanyu&quot;,        &quot;text&quot;: &quot;关于我们&quot;,        &quot;iconPath&quot;: &quot;/images/Customer management.png&quot;,        &quot;selectedIconPath&quot;: &quot;/images/Customer management-fill.png&quot;      &#125;    ]  &#125;&#125;</code></pre><p>编写完app.json文件保存或编译后，创建的页面、导航栏和标签如图02所示，创建的文件目录结构如图03所示。</p><p><img src="https://img-blog.csdnimg.cn/4c9547ff36b04afaaf258d94ef881c50.png#pic_center" alt="03"></p><p>（2）编写.json文件代码，以”教学”页面为例。</p><pre><code>&#123;  &quot;navigationBarBackgroundColor&quot;: &quot;#ff0000&quot;,          //导航栏背景颜色  &quot;navigationBarTextStyle&quot;: &quot;white&quot;,                  //导航栏标题颜色  &quot;navigationBarTitleText&quot;: &quot;教学&quot;                    //导航栏标题文字内容&#125;</code></pre><h2 id="4-思考"><a href="#4-思考" class="headerlink" title="4.思考"></a>4.思考</h2><p>（1）一个小程序页面通常是有哪几个文件构成？</p><blockquote><p>一个小程序的页面由四个文件组成：</p><ul><li>index.js 页面的逻辑层</li><li>index.json 页面的配置</li><li>index.wxml 就是相当于html页面</li><li>index.wxss 页面的样式</li></ul></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、小程序的基本架构&quot;&gt;&lt;a href=&quot;#一、小程序的基本架构&quot; class=&quot;headerlink&quot; title=&quot;一、小程序的基本架构&quot;&gt;&lt;/a&gt;一、小程序的基本架构&lt;/h2&gt;&lt;h2 id=&quot;1-知识点&quot;&gt;&lt;a href=&quot;#1-知识点&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="微信小程序" scheme="http://sang63.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>小程序编程基础（四）</title>
    <link href="http://sang63.github.io/2022/01/18/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://sang63.github.io/2022/01/18/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E5%9B%9B%EF%BC%89/</id>
    <published>2022-01-18T13:13:24.000Z</published>
    <updated>2022-01-19T14:02:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小程序编程基础（四）"><a href="#小程序编程基础（四）" class="headerlink" title="小程序编程基础（四）"></a>小程序编程基础（四）</h2><h2 id="一、随机数求和"><a href="#一、随机数求和" class="headerlink" title="一、随机数求和"></a>一、随机数求和</h2><h3 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1.知识点"></a>1.知识点</h3><p>（1）JavaScript中Array对象函数的使用方法。</p><p>（2）JavaScript中Number对象函数的使用方法。</p><h3 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2.实现方法"></a>2.实现方法</h3><p>JavaScript中的对象包括：字符串、数字、数组、日期等等。对象是拥有属性和方法的数据，属性是静态数据，方法是能够在对象上执行的动作，即动态数据。</p><h4 id="2-1-JavaScript中的Array对象"><a href="#2-1-JavaScript中的Array对象" class="headerlink" title="2.1 JavaScript中的Array对象"></a>2.1 JavaScript中的Array对象</h4><p>用于在单个的变量中存储多个值，其常用属性和方法如下表所示。</p><table><thead><tr><th align="center">属性和方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">length</td><td align="center">设置或返回数组中元素的数目</td></tr><tr><td align="center">concat()</td><td align="center">连接两个或更多的数组，并返回结果</td></tr><tr><td align="center">join()</td><td align="center">把数组的所有元素放入一个字符串。元素通过指定的分隔字符进行分隔</td></tr><tr><td align="center">pop()</td><td align="center">删除并返回数组的最后一个元素</td></tr><tr><td align="center">push()</td><td align="center">向数组的末尾添加一个或更多元素，并返回新的长度</td></tr><tr><td align="center">reverse()</td><td align="center">颠倒数组中的元素顺序</td></tr><tr><td align="center">shift()</td><td align="center">删除并返回数组的第一个元素</td></tr><tr><td align="center">slice()</td><td align="center">从某个已有的数组返回选定的元素</td></tr><tr><td align="center">sort()</td><td align="center">对数组的元素进行排序</td></tr><tr><td align="center">spice()</td><td align="center">删除元素，并向数组添加新元素</td></tr><tr><td align="center">toSource()</td><td align="center">返回对象的源代码</td></tr><tr><td align="center">toString()</td><td align="center">把数组转化为字符串，并返回结果</td></tr><tr><td align="center">toLocalString()</td><td align="center">把数组转换为本地数组，并返回结果</td></tr><tr><td align="center">unshift()</td><td align="center">把数组的开头添加一个或更多元素，并返回新的元素</td></tr><tr><td align="center">valueOf()</td><td align="center">返回数组对象的原始值</td></tr></tbody></table><h4 id="2-2-JavaScript中的Number对象"><a href="#2-2-JavaScript中的Number对象" class="headerlink" title="2.2 JavaScript中的Number对象"></a>2.2 JavaScript中的Number对象</h4><table><thead><tr><th align="center">属性和方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">MAX_VALUE</td><td align="center">可表示的最大的数</td></tr><tr><td align="center">MIN_VALUE</td><td align="center">可表示的最小的数</td></tr><tr><td align="center">NaN</td><td align="center">非数字值</td></tr><tr><td align="center">NEGATIVE_INFINITY</td><td align="center">负无穷大，溢出时返回该值</td></tr><tr><td align="center">POSITIVE_INFINITY</td><td align="center">正无穷大，溢出时返回该值</td></tr><tr><td align="center">toString（）</td><td align="center">把数字转换为字符串，使用指定的基数</td></tr><tr><td align="center">toLocaleString（）</td><td align="center">把数字转换为字符串，使用本地数字格式顺序</td></tr><tr><td align="center">toFixed（）</td><td align="center">把数字转换为字符串，结果的小数点后有指定位数的数字</td></tr><tr><td align="center">toExponential（）</td><td align="center">把对象的值转换为指数计数法</td></tr><tr><td align="center">toPrecision（）</td><td align="center">把数字格式化为指定的长度</td></tr><tr><td align="center">valueOf（）</td><td align="center">返回一个Number对象的基本数字值</td></tr></tbody></table><h3 id="3-案例分析"><a href="#3-案例分析" class="headerlink" title="3.案例分析"></a>3.案例分析</h3><h4 id="3-1案例描述"><a href="#3-1案例描述" class="headerlink" title="3.1案例描述"></a>3.1案例描述</h4><p>设计一个小程序，运行后产生一列100以内的随机数（保留小数点后2位），并显示这些随机数的和；当点击“产生新的随机数”按钮时，产生一列新的随机数，并显示这些随机数的和。</p><h4 id="3-2实现效果"><a href="#3-2实现效果" class="headerlink" title="3.2实现效果"></a>3.2实现效果</h4><p><img src="https://img-blog.csdnimg.cn/50882680e61b4f36b66086b609898e97.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="01 随机数求和"></p><h4 id="3-3案例实现"><a href="#3-3案例实现" class="headerlink" title="3.3案例实现"></a>3.3案例实现</h4><h5 id="3-3-1编写index-wxml文件代码"><a href="#3-3-1编写index-wxml文件代码" class="headerlink" title="3.3.1编写index.wxml文件代码"></a>3.3.1编写index.wxml文件代码</h5><p>代码主要通过列表渲染的方法将逻辑层产生的随机数列表显示在屏幕，并显示随机数列的和，最下面添加一个按钮，用于绑定产生新的随机数的时间函数。</p><pre><code>&lt;view class=&quot;box&quot;&gt;  &lt;view class=&quot;title&quot;&gt;随机数求和&lt;/view&gt;  &lt;view&gt;产生的随机数列为：&lt;/view&gt;  &lt;view wx:for=&quot;&#123;&#123;rand&#125;&#125;&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/view&gt;  &lt;view&gt;随机数列的和为：&#123;&#123;sum1&#125;&#125;&lt;/view&gt;  &lt;button type=&quot;primary&quot; bindtap=&quot;newRand&quot;&gt;产生新的随机数&lt;/button&gt;&lt;/view&gt;</code></pre><h5 id="3-3-2编写index-js文件代码"><a href="#3-3-2编写index-js文件代码" class="headerlink" title="3.3.2编写index.js文件代码"></a>3.3.2编写index.js文件代码</h5><p>代码中主要包含了全局变量和全局函数的定义，并在Page函数中定义了onLoad函数和newRand函数。</p><p>（1）全局变量的定义。首先定义一个全局数组变量rand和一个全局普通变量sum1，rand用来存储产生的随机数列，sum1用来存储随机数列的和。</p><p>（2）全局函数的定义。定义creatRand（）函数用于生产随机数列并求和，该函数首先利用for循环产生6个随机数并将这些数据添加到数组中。Math.random()函数用于生产0<del>1之间的随机数，Math.random()*100能够产生0</del>100之间的随机数，toFixed（2）函数用于实现将产生的随机数保留小数点后2位，乘1的目的是将产生的随机数字符串转换为数值类型。</p><p>（3）rand.push（r）用于将产生的随机数r添加到rand数组中。</p><p>（4）console.log(sum)函数用于在控制台显示sum数据，这种方法对程序调试很有帮助。</p><p>（5）在onLoad（）和newRand（）方法中调用createRand（）方法产生随机数列并求和，然后通过this.setData（）方法将结果渲染到视图层。</p><pre><code>var rand,sum1;                              //定义全局变量function createRand()&#123;  rand=[];                                  //初始化数组变量  sum1=0;                                   //初始化sum变量  for(var i=0;i&lt;6;i++)&#123;    var r=(Math.random()*100).toFixed(2)*1; //产生100以内的保留小数点后2位的随机数并转换为数值类型    rand.push(r);                           //将产生的随机数添加到数组中    sum1+=rand[i];                          //随机数列求和    console.log(rand[i]);                   //在控制台显示数组元素  &#125;  console.log(sum1);&#125;;Page(&#123;  onLoad:function()&#123;    createRand（）;                         //调用产生随机数的全局函数    this.setData(&#123;      sum1:sum1    &#125;)  &#125;,  newRand:function()&#123;      createRand();                          //调用产生随机数的全局函数    this.setData(&#123;      rand:rand,      sum1:sum1    &#125;)  &#125;&#125;)</code></pre><h2 id="二、计时器"><a href="#二、计时器" class="headerlink" title="二、计时器"></a>二、计时器</h2><h3 id="1-知识点-1"><a href="#1-知识点-1" class="headerlink" title="1.知识点"></a>1.知识点</h3><p>（1）函数number setTimeout(function callback,number delay,any rest)的使用方法</p><p>（2）函数number setInterval(function callback,number delay,any rest)的使用方法</p><h3 id="2-实现方法-1"><a href="#2-实现方法-1" class="headerlink" title="2.实现方法"></a>2.实现方法</h3><p>（1）函数number setTimeout(function callback,number delay,any rest)。设定一个定时器，在定时到期以后执行注册的回调函数。参数callback为回调函数，参数delay为延迟的时间，函数的调用会在该延迟之后发生，单位为ms。参数rest，param1，param2，…，paramN等为附加参数，他们会作为参数传递给回调函数。返回值number为定时器的编号。这个值可以传递给clearTimeout来取消该定时。</p><p>（2）函数函数number setInterval(function callback,number delay,any rest)。设定一个定时器，按照指定的周期（以ms计）来执行注册的回调函数。参数callback为回调函数，参数delay为执行回调函数之间的时间间隔，单位为ms。参数rest，param1，param2，…，paramN等为附加参数，他们会作为参数传递给回调函数。返回值number为定时器的编号。这个值可以传递给clearInterval来取消该定时。</p><p>（3）函数clealInterval(number intervalID)。取消由setInterval设置的定时器。参数intervalID为要取消的定时器的ID。</p><h3 id="3-案例分析-1"><a href="#3-案例分析-1" class="headerlink" title="3.案例分析"></a>3.案例分析</h3><h4 id="3-1案例描述-1"><a href="#3-1案例描述-1" class="headerlink" title="3.1案例描述"></a>3.1案例描述</h4><p>设计一个实现倒计时功能的小程序，小程序运行后，首先显示空白页面，过2s后才显示计时界面，点击“开始计时”按钮后开始倒计时，此时“开始计时”按钮变为失效状态。点击“停止计时”按钮后停止计时，此时“开始计时”按钮变为可用状态。</p><h4 id="3-2实现效果-1"><a href="#3-2实现效果-1" class="headerlink" title="3.2实现效果"></a>3.2实现效果</h4><p><img src="https://img-blog.csdnimg.cn/fa0f1952b7ca407a84f682262eb1d994.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="02 初始界面"></p><p><img src="https://img-blog.csdnimg.cn/ae450ec3bfb64d158256bd5f3a5936b5.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="03 计时界面"></p><h3 id="3-3案例实现-1"><a href="#3-3案例实现-1" class="headerlink" title="3.3案例实现"></a>3.3案例实现</h3><h4 id="3-3-1编写index-wxml文件代码-1"><a href="#3-3-1编写index-wxml文件代码-1" class="headerlink" title="3.3.1编写index.wxml文件代码"></a>3.3.1编写index.wxml文件代码</h4><p>文件主要由计时器时数字系那是界面和2个按钮组成，计时数字显示界面布局和样式有.time样式来设置，2个按钮的布局由.btnLayout样式来设置，按钮的宽度由button样式设置。2个按钮分别绑定了start和stop函数来实现开始计时和停止计时。</p><pre><code>&lt;view class=&quot;box&quot;&gt;  &lt;view class=&quot;title&quot;&gt;计时器&lt;/view&gt;  &lt;view class=&quot;time&quot;&gt;&#123;&#123;num&#125;&#125;&lt;/view&gt;  &lt;view class=&quot;btnLayout&quot;&gt;    &lt;button bindtap=&quot;start&quot; disabled=&quot;&#123;&#123;btnDisable&#125;&#125;&quot;&gt;开始计时&lt;/button&gt;    &lt;button bindtap=&quot;stop&quot;&gt;停止计时&lt;/button&gt;  &lt;/view&gt;&lt;/view&gt;</code></pre><h4 id="3-3-2编写index-wxss文件代码"><a href="#3-3-2编写index-wxss文件代码" class="headerlink" title="3.3.2编写index.wxss文件代码"></a>3.3.2编写index.wxss文件代码</h4><pre><code>button&#123;  width: 45%;&#125;.time&#123;  width: 90%;  line-height: 200rpx;  background-color: #eef0dd;  color: red;  font-size: 100px;  text-align: center;  border: 1px solid silver;  border-radius: 30px;  margin: 15px;&#125;.btnLayout&#123;  display: flex;  flex-direction: row;&#125;</code></pre><h4 id="3-3-3编写index-js文件代码"><a href="#3-3-3编写index-js文件代码" class="headerlink" title="3.3.3编写index.js文件代码"></a>3.3.3编写index.js文件代码</h4><p>文件定义了2个全局变量：num和timerID，定义了5个函数：onLoad、show、start、stop和timer。onLoad函数通过调用setTimeout函数，使计时页面在2s后显示；show函数用于显示计时器界面；start函数通过调用setInterval函数实现倒计时；stop函数通过调用clearInterval函数实现停止计时；timer函数用于实现计时过程。</p><pre><code>var num=60;               //计时器显示的数字var timerID;              //计时器IDPage(&#123;  data:&#123;    hidden:true,          //小程序运行时不显示计时桌面   btnDisabled:false,      //设置“开始计时”按钮一开始是可用的   num:num  &#125;,  onLoad:function(options)&#123;    var that=this;    setTimeout(()=&gt;&#123;      that.show()    &#125;,2000)               //2s后显示计时界面  &#125;,  show:function()&#123;        //显示计时界面函数    var that=this;    that.setData(&#123;      hidden:false    &#125;)  &#125;,  start:function()&#123;       //显示计时界面    var that=this;    that.setData(&#123;      btnDisabled:true     //设置“开始计时”按钮不可用    &#125;)    timerID=setInterval(()=&gt;&#123;      that.timer()    &#125;,1000)                //每隔1s调用一次timer函数  &#125;,  stop:function()&#123;         //停止计时函数    clearInterval(timerID) //清除计时器    this.setData(&#123;               btnDisabled:false    //设置“开始计时”按钮可用    &#125;)  &#125;,  timer:function()&#123;        //计时函数    var that=this;    console.log(num)    if(num&gt;0)&#123;      that.setData(&#123;        num:num--          //每次减1      &#125;)    &#125;else&#123;      that.setData(&#123;        num:0      &#125;)    &#125;    console.log(num)  &#125;&#125;)</code></pre><h3 id="4-思考"><a href="#4-思考" class="headerlink" title="4.思考"></a>4.思考</h3><p>（1）setTimeout（）函数和setInterval（）函数有什么区别？</p><p>setTimeout()和setInterval()经常被用来处理延时和定时任务。使用setTimeout（）处理延时任务，而使用setInterval（）方法处理定时任务；</p><p>setTimeout() 方法用于在指定的毫秒数后调用函数或计算表达式,而setInterval()则可以在每隔指定的毫秒数循环调用函数或表达式，直到 clearInterval把它清除。</p><p>我们可以看到两个函数十分类似，只不过前者执行一次，而后者可以执行多次，两个函数的参数也相同，第一个参数是要执行的code或句柄，第二个是延迟的毫秒数。</p><pre><code>语法：setTimeout(function ()&#123;&#125;,time);//time 毫秒之后执行setInterval(function ()&#123;&#125;,time)；//每隔time 毫秒执行</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;小程序编程基础（四）&quot;&gt;&lt;a href=&quot;#小程序编程基础（四）&quot; class=&quot;headerlink&quot; title=&quot;小程序编程基础（四）&quot;&gt;&lt;/a&gt;小程序编程基础（四）&lt;/h2&gt;&lt;h2 id=&quot;一、随机数求和&quot;&gt;&lt;a href=&quot;#一、随机数求和&quot; class</summary>
      
    
    
    
    
    <category term="微信小程序" scheme="http://sang63.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>小程序编程基础（三）</title>
    <link href="http://sang63.github.io/2022/01/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://sang63.github.io/2022/01/17/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%89%EF%BC%89/</id>
    <published>2022-01-17T13:18:43.000Z</published>
    <updated>2022-01-17T14:29:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小程序编程基础（三）"><a href="#小程序编程基础（三）" class="headerlink" title="小程序编程基础（三）"></a>小程序编程基础（三）</h2><h2 id="一、-摄氏温度转华氏温度"><a href="#一、-摄氏温度转华氏温度" class="headerlink" title="一、  摄氏温度转华氏温度"></a>一、  摄氏温度转华氏温度</h2><h3 id="1-知识点"><a href="#1-知识点" class="headerlink" title="1.知识点"></a>1.知识点</h3><p>（1）input组件的使用方法。</p><p>（2）数学表达式转化为JavaScript表达式的方法。</p><p>（3）JavaScript程序顺序执行的实现方法。</p><h3 id="2-实现方法"><a href="#2-实现方法" class="headerlink" title="2.实现方法"></a>2.实现方法</h3><p>（1）JavaScript中顺序结构的程序设计方法。顺序结构程序设计是指按照解决问题的顺序写出相应的语句，它的执行顺序是自上而下，依次而行。</p><p>（2）JavaScript中数学运算的基本方法。JavaScript中的数学运算需要将数学表达式利用JavaScript运算符和函数等转换为JavaScript表达式。</p><p>（3）input输入框组件使用方法。该组件主要用于输入数据，气场用属性如下表所示。</p><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">默认值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">value</td><td align="center">string</td><td align="center"></td><td align="center">输入框的初始内容</td></tr><tr><td align="center">type</td><td align="center">string</td><td align="center">text</td><td align="center">input的类型</td></tr><tr><td align="center">password</td><td align="center">boolean</td><td align="center">false</td><td align="center">是否是密码类型</td></tr><tr><td align="center">placeholder</td><td align="center">string</td><td align="center"></td><td align="center">输入框为空时的占位符</td></tr><tr><td align="center">placeholder-style</td><td align="center">string</td><td align="center"></td><td align="center">指定paceholder的样式</td></tr><tr><td align="center">maxlength</td><td align="center">number</td><td align="center">140</td><td align="center">最大输入长度，设置为-1时不限制最大长度</td></tr><tr><td align="center">bindput</td><td align="center">eventhandle</td><td align="center"></td><td align="center">键盘输入时触发，event.datail&#x3D;{value,cursor,keyCode},keyCode为键值，2.1.2起支持，处理函数可以直接return一个字符串，将替换输入框的内容</td></tr><tr><td align="center">bindfocus</td><td align="center">eventhandle</td><td align="center"></td><td align="center">输入框局聚集时触发，event.detail&#x3D;{value,height},height为键盘高度，在基础库1.9.90起支持</td></tr><tr><td align="center">bindblur</td><td align="center">eventhandle</td><td align="center"></td><td align="center">输入框失去焦点时触发，event.datail&#x3D;{value:value}</td></tr></tbody></table><p>type属性是指利用真机运行时，当在输入框中输入数据时，根据type属性指定的类型导出来的键盘类型，而不是输入内容的类型。</p><table><thead><tr><th align="center">值</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">text</td><td align="center">文本输入键盘</td></tr><tr><td align="center">number</td><td align="center">数字输入键盘</td></tr><tr><td align="center">idcard</td><td align="center">身份证输入键盘</td></tr><tr><td align="center">digit</td><td align="center">带小数点的数字键盘</td></tr></tbody></table><h3 id="3-案例分析"><a href="#3-案例分析" class="headerlink" title="3.案例分析"></a>3.案例分析</h3><h4 id="3-1案例描述"><a href="#3-1案例描述" class="headerlink" title="3.1案例描述"></a>3.1案例描述</h4><p>设计一个根据摄氏温度C求缓释温度F的微信小程序，华氏温度的计算公式如下：</p><p><img src="https://img-blog.csdnimg.cn/3b55cc8ea4144f36a9031d9c33645f21.png#pic_center" alt="公式一"></p><h4 id="3-2实现效果"><a href="#3-2实现效果" class="headerlink" title="3.2实现效果"></a>3.2实现效果</h4><p><img src="https://img-blog.csdnimg.cn/eeef1e6a013643148c38fca094790648.png#pic_center" alt="01"></p><h4 id="3-3案例实现"><a href="#3-3案例实现" class="headerlink" title="3.3案例实现"></a>3.3案例实现</h4><p>（1）编写index.wxml文件代码。代码中使用了input组件输入数据，使用了placeholder属性提示用户输入，使用了digit属性实现在真机上输入是弹出数字键盘，使用bindblur属性引发input组件失去焦点时的动作组件–根据摄氏温度计算华氏温度。此外，input组件样式通过input样式进行设置。</p><pre><code>&lt;view class=&quot;box&quot;&gt;  &lt;view class=&quot;title&quot;&gt;摄氏温度转华氏温度&lt;/view&gt;  &lt;view&gt;    &lt;input type=&quot;digit&quot; placeholder=&quot;请输入摄氏温度&quot; bindblur=&quot;calc&quot; /&gt;  &lt;/view&gt;  &lt;view&gt;华氏温度为：&#123;&#123;F&#125;&#125;&lt;/view&gt;&lt;/view&gt;</code></pre><p>（2）编写index.wxss文件代码。设置input组建的编剧和下框条样式。</p><pre><code>input&#123;  margin: 20px 0;  border-bottom: 1px solid blue;&#125;</code></pre><p>（3）编写index.js文件代码。实现由input组件失去焦点时印发的动作的时间bindblur，该事件对应的函数是calc，函数的参数e表示input组件失去焦点事件，函数中首先定义2个变量C和F用来存储摄氏温度和华氏温度，然后利用e.detail.value获取input组件中的数值并赋值给C，然后根据C计算出F，并通过this.setData（）函数将F值由逻辑层传递给视图层，并在index.wxml文件中显示出来。</p><pre><code>Page(&#123;  calc:function(e)&#123;    var C,F;                   /*变量的定义*/    C=e.detail.value;          /*获取输入框中输入的数值*/    this.setData(&#123;      F:C*9/5+32               /*求出华氏温度的值F，并把该值传递到index.wxml文件中的&#123;&#123;F&#125;&#125;*/    &#125;)  &#125;&#125;)</code></pre><h2 id="二、条件语句与数学函数"><a href="#二、条件语句与数学函数" class="headerlink" title="二、条件语句与数学函数"></a>二、条件语句与数学函数</h2><h3 id="1-知识点-1"><a href="#1-知识点-1" class="headerlink" title="1.知识点"></a>1.知识点</h3><p>（1）JavaScript中的条件语句。</p><p>（2）JavaScript中数学函数的使用方法。</p><h3 id="2-实现方法-1"><a href="#2-实现方法-1" class="headerlink" title="2.实现方法"></a>2.实现方法</h3><h4 id="2-1-JavaScript中的条件语句"><a href="#2-1-JavaScript中的条件语句" class="headerlink" title="2.1 JavaScript中的条件语句"></a>2.1 JavaScript中的条件语句</h4><p>在JavaScript中使用以下语句：</p><ul><li>if语句：当指定条件为true时，使用该语句来执行代码。</li><li>if…else语句：当指定条件为true时执行代码，当条件为false时执行其他代码。</li><li>if…else if …else语句：使用该语句来选择多个代码块之一来执行。</li><li>switch语句：使用该语句来选择多个代码块之一来执行。</li></ul><p>（1）if语句</p><pre><code>if(条件)&#123;  条件为true时执行的代码&#125;</code></pre><p>（2）if…else语句</p><pre><code>if(条件)&#123;  条件为true时执行的代码块&#125;else&#123;  条件为false时执行的代码块&#125;</code></pre><p>（3）if…else if…else语句</p><pre><code>if(条件1)&#123;  条件1为true时执行的代码块&#125;else if(条件2)&#123;  条件1为false而条件2为true时执行的代码块&#125;else&#123;  条件1和条件2都为false时执行的代码块&#125;</code></pre><p>（4）switch语句</p><pre><code>switch(表达式)&#123;  case n1:    代码块    break；  case n2：    代码块    break；  ...  default:    默认代码块&#125;</code></pre><p>代码解释：</p><ul><li>计算一次switch表达式。</li><li>把表达式的值与每一个case的值进行对比，否则，执行默认代码块。</li><li>如果存在匹配，则执行关联代码。</li></ul><h4 id="2-2-JavaScript中的Math对象"><a href="#2-2-JavaScript中的Math对象" class="headerlink" title="2.2 JavaScript中的Math对象"></a>2.2 JavaScript中的Math对象</h4><p>JavaScript中的所有事物都是对象，对象是拥有属性和方法的数据，属性是与对象相关的值，方法是能够在对象上执行的动作。Math对象用于执行数学内容，它的常用属性和方法如下表所示。</p><table><thead><tr><th align="center">属性和方法</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">E</td><td align="center">返回算数常量e，即自然对数的底线(约等于2.718)</td></tr><tr><td align="center">PI</td><td align="center">返回圆周率(约等于3.14159)</td></tr><tr><td align="center">abs(x)</td><td align="center">返回数的绝对值</td></tr><tr><td align="center">ceil(x)</td><td align="center">对数进行上舍入</td></tr><tr><td align="center">cos(x)</td><td align="center">返回角的余弦</td></tr><tr><td align="center">exp(x)</td><td align="center">返回e的指数</td></tr><tr><td align="center">floor(x)</td><td align="center">对数进行下舍入</td></tr><tr><td align="center">log(x)</td><td align="center">返回数的自然对数(底为e)</td></tr><tr><td align="center">max(x,y)</td><td align="center">返回x和y的最大值</td></tr><tr><td align="center">min(x,y)</td><td align="center">返回x和y的最小值</td></tr><tr><td align="center">pow(x,y)</td><td align="center">返回x的y次幂</td></tr><tr><td align="center">random()</td><td align="center">返回0~1之间的随机数</td></tr><tr><td align="center">round(x)</td><td align="center">把数四舍五入为最接近的整数</td></tr><tr><td align="center">sin(x)</td><td align="center">返回角的正弦</td></tr><tr><td align="center">sqrt(x)</td><td align="center">返回数的平方根</td></tr><tr><td align="center">tan(x)</td><td align="center">返回角的正切</td></tr><tr><td align="center">valueOf()</td><td align="center">返回Math对象的原始值</td></tr></tbody></table><h3 id="3-案例分析-1"><a href="#3-案例分析-1" class="headerlink" title="3.案例分析"></a>3.案例分析</h3><h4 id="3-1案例描述-1"><a href="#3-1案例描述-1" class="headerlink" title="3.1案例描述"></a>3.1案例描述</h4><p>设计一个利用条件结构和数学函数进行计算的小程序。当输入x值时，根据下面的公式计算出y的值。</p><p><img src="https://img-blog.csdnimg.cn/91040cc1f043483b85e57b338ebd052f.png" alt="公式二"></p><h4 id="3-2实现效果-1"><a href="#3-2实现效果-1" class="headerlink" title="3.2实现效果"></a>3.2实现效果</h4><p><img src="https://img-blog.csdnimg.cn/5471045cb708414f8abae7048a2450d8.png#pic_center" alt="02"></p><h4 id="3-3案例实现-1"><a href="#3-3案例实现-1" class="headerlink" title="3.3案例实现"></a>3.3案例实现</h4><p>（1）编写index.wxml文件代码</p><pre><code>&lt;view class=&quot;box&quot;&gt;  &lt;view class=&quot;title&quot;&gt;条件语句和数学函数&lt;/view&gt;  &lt;view&gt;    &lt;input placeholder=&quot;请输入X的值&quot; bindblur=&quot;jisuan&quot; /&gt;  &lt;/view&gt;  &lt;view&gt;计算Y的值为：&#123;&#123;y&#125;&#125;&lt;/view&gt;&lt;/view&gt;</code></pre><p>（2）编写index.wxss文件代码</p><pre><code>input&#123;  margin: 20px 0;  border-bottom: 1px solid blue;&#125;</code></pre><p>（3）编写index.js文件代码</p><p>文件定义了“jisuan”函数，该函数根据x的值，利用条件语句和数学函数计算出了y的值，并通过setData函数将计算结果渲染到视图层。</p><pre><code>page（&#123;    jisuan:function(e)&#123;    var x,y;                            /*定义局部变量x和y*/    x=e.detail.value;                   /*获取input组件的value值并赋值给x*/    if(x&lt;0)&#123;                            /*根据x的值进行判断，并求出y的值*/      y=Math.abs(x);    &#125;else if(x&lt;10)&#123;      y=Math.exp(x)*Math.sin(x);    &#125;else if(x&lt;20)&#123;      y=Math.pow(x,3);    &#125;else&#123;      y=(3+2*x)*Math.log(x);    &#125;    this.setData(&#123;      y:y                                /*将局部变量y赋值给绑定变量y*/    &#125;)  &#125;&#125;）</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;小程序编程基础（三）&quot;&gt;&lt;a href=&quot;#小程序编程基础（三）&quot; class=&quot;headerlink&quot; title=&quot;小程序编程基础（三）&quot;&gt;&lt;/a&gt;小程序编程基础（三）&lt;/h2&gt;&lt;h2 id=&quot;一、-摄氏温度转华氏温度&quot;&gt;&lt;a href=&quot;#一、-摄氏温度转华</summary>
      
    
    
    
    
    <category term="微信小程序" scheme="http://sang63.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>小程序编程基础（二）</title>
    <link href="http://sang63.github.io/2022/01/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://sang63.github.io/2022/01/09/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-01-09T05:24:13.000Z</published>
    <updated>2022-01-09T05:30:34.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小程序编程基础（二）"><a href="#小程序编程基础（二）" class="headerlink" title="小程序编程基础（二）"></a>小程序编程基础（二）</h2><h2 id="1-盒模型"><a href="#1-盒模型" class="headerlink" title="1.盒模型"></a>1.盒模型</h2><h3 id="1-1知识点"><a href="#1-1知识点" class="headerlink" title="1.1知识点"></a>1.1知识点</h3><p>（1）盒模型的结构。</p><p>（2）边框的设置方法，包括边框宽度、样式和颜色。</p><p>（3）编剧的设置方法，包括外边距和内边距。</p><h3 id="1-2盒模型"><a href="#1-2盒模型" class="headerlink" title="1.2盒模型"></a>1.2盒模型</h3><p>所有WXML元素都可以看做盒子，在WXSS中，box model这一术语是用来设置布局时使用。盒模型本质上是一个盒子，封装周围WXML元素，他包括边距，边框，填充和实际内容，模型结构如图01所示，各部分说明如下。</p><p><img src="https://img-blog.csdnimg.cn/5cf3d58db2954c3aa2dc94929da511a0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="01"></p><p>（1）element（内容）：盒子的内容，包括文本和图像。</p><p>（2）padding（内边距）：清楚内容周围的区域，内边距是透明的。</p><p>（3）border（边框）：围绕在内边距和内容外的边框。允许指定一个元素边框的样式、宽度和颜色。</p><p>（4）margin（外边距）：清除边框外的区域，外边距是透明的。</p><p>（5）width（宽度）：盒子内容的宽度。</p><p>（6）height（高度）：盒子内容的高度。</p><h3 id="1-3边框样式"><a href="#1-3边框样式" class="headerlink" title="1.3边框样式"></a>1.3边框样式</h3><p>border-style属性用来定义边框的样式，属性值如下表所示。</p><table><thead><tr><th align="center">边框样式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">none</td><td align="center">默认无边框</td></tr><tr><td align="center">dotted</td><td align="center">定义一个点线边框</td></tr><tr><td align="center">dashed</td><td align="center">定义一个虚线边框</td></tr><tr><td align="center">soild</td><td align="center">定义实线边框</td></tr><tr><td align="center">double</td><td align="center">定义两个边框。两个边框的宽和border-width的值相同</td></tr><tr><td align="center">groove</td><td align="center">定义3D沟槽边框。效果取决于边框的颜色值</td></tr><tr><td align="center">ridge</td><td align="center">定义3D脊边框。效果取决于边框的颜色值</td></tr><tr><td align="center">inset</td><td align="center">定义一个3D嵌入边框。效果取决于边框的颜色值</td></tr><tr><td align="center">outset</td><td align="center">定义一个3D突出边框。效果取决于边框的颜色值</td></tr></tbody></table><h3 id="1-4边框宽度"><a href="#1-4边框宽度" class="headerlink" title="1.4边框宽度"></a>1.4边框宽度</h3><p>border-width属性用于设置边框宽度。</p><p>（1）指定长度值，单位为px，pt，cm，em等。</p><p>（2）使用3个关键字之一：thick、medium（默认值）和thin。</p><h3 id="1-5边框颜色"><a href="#1-5边框颜色" class="headerlink" title="1.5边框颜色"></a>1.5边框颜色</h3><p>border-color属性用于设置边框的颜色。</p><p>（1）Name：指定颜色名称，如‘red’，‘yellow’。</p><p>（2）RGB：指定RGB值，如’rgb（0,255,0）‘。</p><p>（3）RGBA：指定RGBA值，如‘rgba（255,0,0,1）’。</p><p>（4）Hex：指定十六进制值，如‘#911005’。</p><blockquote><p>  注意：R(Red)G(Green)B(Blue)的范围在0<del>255之间，A(Alpha）表示透明度，其范围在0</del>1之间。</p></blockquote><h3 id="1-6单独设置各边"><a href="#1-6单独设置各边" class="headerlink" title="1.6单独设置各边"></a>1.6单独设置各边</h3><p>可以通过border-top、border-right、border-bottom、border-left属性设置不同的侧面具有不同的边框。</p><h3 id="1-7一次性设置边框属性"><a href="#1-7一次性设置边框属性" class="headerlink" title="1.7一次性设置边框属性"></a>1.7一次性设置边框属性</h3><p>可以利用border属性一次性设置边框宽度、边框样式和边框颜色，设置方法是：border：border-width border-color，如：border：3px dashed #00ff00。</p><h3 id="1-8案例分析"><a href="#1-8案例分析" class="headerlink" title="1.8案例分析"></a>1.8案例分析</h3><h4 id="1-8-1实现效果"><a href="#1-8-1实现效果" class="headerlink" title="1.8.1实现效果"></a>1.8.1实现效果</h4><p><img src="https://img-blog.csdnimg.cn/502aeb5a08f6420991131f7af69b75ec.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="02"></p><h4 id="1-8-2案例实现"><a href="#1-8-2案例实现" class="headerlink" title="1.8.2案例实现"></a>1.8.2案例实现</h4><p>（1）编写index.wxml文件代码</p><pre><code>&lt;!--index.wxml--&gt;&lt;view class=&quot;box&quot;&gt;  &lt;view class=&quot;title&quot;&gt;盒子模型&lt;/view&gt;  &lt;view class=&quot;boxModel01&quot;&gt;    .boxModel01&#123;    width: 80%;    height: 100px;    background-color: #011004;    border: 1px dashed #f00;    padding: 20px;    &#125;  &lt;/view&gt;  &lt;view class=&quot;boxModel02&quot;&gt;    .boxModel02&#123;    width: 80%;    height: 100px;    border: 5px solid rgb(0,255,0);    padding-top: 20px;    margin-bottom: 20px;    &#125;  &lt;/view&gt;  &lt;view class=&quot;boxModel03&quot;&gt;    .boxModel03&#123;    width: 80%;    height: 120px;    border: 5px dotted rgba(0,0,255,0.3);    padding-left: 20px;    margin: 0 20px;    &#125;  &lt;/view&gt;&lt;/view&gt;</code></pre><p>（2）编写index.wxss文件代码</p><pre><code>/**index.wxss**/.boxModel01 &#123;  width: 80%;  height: 100px;  background-color: #cec659;  /*背景颜色*/  border: 1px dashed #f00;  padding: 20px；             /*内边距*/  margin: 20px;              /*外边距*/&#125;.boxModel02 &#123;  width: 80%;  height: 100px;  border: 5px solid rgb(0, 255, 0);  padding-top: 20px;        /*内上边距*/  margin-bottom: 20px;      /*外下边距*/&#125;.boxModel03 &#123;  width: 80%;  height: 120px;  border: 5px dotted rgba(0, 0, 255, 0.3);  padding-left: 20px;      /*内左边距*/  margin: 0 20px;          /*外上下边距为0，左右边距为20px*/&#125;</code></pre><h3 id="1-9总结与思考"><a href="#1-9总结与思考" class="headerlink" title="1.9总结与思考"></a>1.9总结与思考</h3><p>（1）盒模型中的内容超出了给定的模型尺寸，即超出了width和height限定的范围，模型应该如何处理？</p><p>overflow属性</p><ul><li>visible：默认值，内容不会被修剪，会出现在元素框之外；</li><li>hidden：内容会被修剪，并且其余内容是不可见的；</li><li>scroll：内容会被修剪，但是浏览器会显示滚动条，以便查看其余的内容；</li><li>auto：如果内容被修剪，则浏览器会显示滚动条，以便查看其他的内容；</li><li>inherit：规定应该从父元素继承overflow属性的值。</li></ul><p>（2）盒模型的背景包括padding范围吗？</p><ul><li>padding是元素内容到元素边框之间的距离，叫内填充、补白或内边距； </li><li>padding区域内会显示背景色和背景图片；</li></ul><p>元素框的总宽度 &#x3D; 元素（element）的width + padding的左边距和右边距的值 + margin的左边距和右边距的值 + border的左右宽度；</p><p>元素框的总高度 &#x3D; 元素（element）的height + padding的上下边距的值 + margin的上下边距的值 ＋ border的上下宽度。</p><h2 id="2-flex弹性盒模型布局"><a href="#2-flex弹性盒模型布局" class="headerlink" title="2.flex弹性盒模型布局"></a>2.flex弹性盒模型布局</h2><h3 id="2-1知识点"><a href="#2-1知识点" class="headerlink" title="2.1知识点"></a>2.1知识点</h3><p>（1）flex布局方法。</p><p>（2）利用line-height属性实现文字垂直居中对齐的方法。</p><h3 id="2-2flex简介"><a href="#2-2flex简介" class="headerlink" title="2.2flex简介"></a>2.2flex简介</h3><p>flex是flexible box的缩写，以为“弹性布局”，用来对盒状模型进行布局。采用翻了下布局的元素称为flex容器（flex container），简称“容器”。它的所有子元素自动成为容器成员，称为flex项目，简称“项目”。容器默认存在两根轴：主轴和叉轴。主轴的开始位置（与边框的交叉点）叫做main start，结束位置叫做main end；交叉轴的开始位置叫做cross start，结束的位置叫做cross end。项目默认沿主轴排列。但项目占据的主轴空间叫做main size，占据的交叉轴空间叫做cross size，如下图03所示。</p><p><img src="https://img-blog.csdnimg.cn/c2aa67dfb05d48b6ae0d268bdc32d49d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="03"></p><p>（1）flex容器布局属性</p><table><thead><tr><th align="center">属性</th><th align="center">含义</th><th align="center">合法值</th></tr></thead><tbody><tr><td align="center">flex-direction</td><td align="center">主轴的方向（即项目的排列方向）</td><td align="center">row，row-reverse，column，column-reverse</td></tr><tr><td align="center">flex-wrap</td><td align="center">如果一条轴线排不下，如何换行</td><td align="center">nowrap，wrap，wrap-reverse</td></tr><tr><td align="center">justify-content</td><td align="center">项目在主轴上的对齐方式</td><td align="center">flex-start，flex-end，center，space-between，space-around</td></tr><tr><td align="center">align-items</td><td align="center">项目在交叉轴上的对齐方式</td><td align="center">flex-start，flex-end，center，baseline，stretch</td></tr><tr><td align="center">align-content</td><td align="center">项目在交叉轴上有多跟轴线时的对齐方式</td><td align="center">flex-start，flex-end，space-between，center，space-around，stretch</td></tr></tbody></table><p>（2）flex项目布局属性</p><table><thead><tr><th align="center">属性</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">order</td><td align="center">项目的排列顺序。数值越小排列越靠前，默认为0</td></tr><tr><td align="center">flex-grow</td><td align="center">各项目宽度之和小于容器宽度时，各项目分配容器剩余宽度的放大比例，默认为0，即不放大</td></tr><tr><td align="center">flex-shrink</td><td align="center">各项目宽度之和大于容器宽度时，各项目缩小自己宽度比例，默认为1，即该项目将缩小</td></tr><tr><td align="center">flex-basis</td><td align="center">元素宽度的属性，和width功能相同，但比width的优先级高</td></tr><tr><td align="center">flex</td><td align="center">是flex-grow，flex-shrink和flex-basis的缩写，默认值为0 1 auto。后两个属性可选</td></tr><tr><td align="center">align-self</td><td align="center">允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch</td></tr></tbody></table><h3 id="2-3利用line-heught设置文本垂直居中原理"><a href="#2-3利用line-heught设置文本垂直居中原理" class="headerlink" title="2.3利用line-heught设置文本垂直居中原理"></a>2.3利用line-heught设置文本垂直居中原理</h3><p>line-height可以理解为每行文字所占的高度。比如说，有一行高度为20px的文字，如果设置为line-height：50px，那就是说，这行文字的高度将会占50px，由于每个字的高度只有20px，于是浏览器就把多出来的30px在这行文字的上面加上了15px，下面加上了15px，这样文字就在这50px的空间内是居中了。</p><h3 id="2-4案例分析"><a href="#2-4案例分析" class="headerlink" title="2.4案例分析"></a>2.4案例分析</h3><h4 id="2-4-1实现效果"><a href="#2-4-1实现效果" class="headerlink" title="2.4.1实现效果"></a>2.4.1实现效果</h4><p><img src="https://img-blog.csdnimg.cn/0ecc111ef9fb47ab8c05832488a4fea0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="04"></p><h4 id="2-4-2案例实现"><a href="#2-4-2案例实现" class="headerlink" title="2.4.2案例实现"></a>2.4.2案例实现</h4><p>（1）index.wxml</p><pre><code>&lt;view class=&quot;box&quot;&gt;  &lt;view class=&quot;title&quot;&gt;页面布局示例&lt;/view&gt;  &lt;!-- 实现三栏水平均匀分布 --&gt;  &lt;view class=&quot;boxModel04&quot;&gt;    &lt;view style=&quot;background-color:red;flex-grow:1&quot;&gt;1&lt;/view&gt;    &lt;view style=&quot;background-color:yellow;flex-grow:2&quot;&gt;2&lt;/view&gt;    &lt;view style=&quot;background-color:blue;flex-grow:1&quot;&gt;3&lt;/view&gt;  &lt;/view&gt;  ----------------------------------------------------  &lt;!-- 实现左右混合布局 --&gt;  &lt;view class=&quot;boxModel05&quot;&gt;    &lt;view style=&quot;background-color:red;width:50%;flex-grow:1&quot;&gt;1&lt;/view&gt;    &lt;view style=&quot;display:flex;flex-direction:column;width:50%;flex-grow:1;line-height:150rpx&quot;&gt;      &lt;view style=&quot;background-color:yellow;flex-grow:1&quot;&gt;2&lt;/view&gt;      &lt;view style=&quot;background-color:blue;flex-grow:1&quot;&gt;3&lt;/view&gt;    &lt;/view&gt;  &lt;/view&gt;  ---------------------------------------------------  &lt;!-- 实现上下混合布局 --&gt;  &lt;view style=&quot;display:flex;text-align:center;flex-direction:column;line-height:300rpx&quot;&gt;    &lt;view style=&quot;background-color:red;height:100rpx;line-height:100rpx&quot;&gt;1&lt;/view&gt;    &lt;view style=&quot;display:flex;flex-direction:row;flex-grow:1;line-height:200rpx&quot;&gt;      &lt;view style=&quot;background-color:yellow;flex-grow:1&quot;&gt;2&lt;/view&gt;      &lt;view style=&quot;background-color:blue;flex-grow:1&quot;&gt;3&lt;/view&gt;    &lt;/view&gt;  &lt;/view&gt;&lt;/view&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;小程序编程基础（二）&quot;&gt;&lt;a href=&quot;#小程序编程基础（二）&quot; class=&quot;headerlink&quot; title=&quot;小程序编程基础（二）&quot;&gt;&lt;/a&gt;小程序编程基础（二）&lt;/h2&gt;&lt;h2 id=&quot;1-盒模型&quot;&gt;&lt;a href=&quot;#1-盒模型&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="微信小程序" scheme="http://sang63.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>小程序编程基础（一）</title>
    <link href="http://sang63.github.io/2022/01/04/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://sang63.github.io/2022/01/04/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-01-04T13:30:00.000Z</published>
    <updated>2022-01-04T13:45:30.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="小程序编程基础（一）"><a href="#小程序编程基础（一）" class="headerlink" title="小程序编程基础（一）"></a>小程序编程基础（一）</h2><h2 id="1-字体样式设置"><a href="#1-字体样式设置" class="headerlink" title="1.字体样式设置"></a>1.字体样式设置</h2><h3 id="1-1知识点"><a href="#1-1知识点" class="headerlink" title="1.1知识点"></a>1.1知识点</h3><p>（1）各种字体样式属性名称及其含义。</p><p>（2）利用style和class设置字体样式的方法。</p><p>（3）在index.wxss和app.wxss中定义样式类的方法。</p><table><thead><tr><th align="center">属性</th><th align="center">含义</th><th align="center">属性值列举</th></tr></thead><tbody><tr><td align="center">font-family</td><td align="center">字体类型</td><td align="center">serif,sans-serif,monospace,cursive,fantasy,…</td></tr><tr><td align="center">font-size</td><td align="center">字体大小</td><td align="center">5px&#x2F;rpx&#x2F;cm,large,small,medium,larger,smaller,…</td></tr><tr><td align="center">font-style</td><td align="center">字体倾斜</td><td align="center">italic,normal,oblique,…</td></tr><tr><td align="center">font-weight</td><td align="center">字体粗细</td><td align="center">bold,bolder,lighter,…</td></tr></tbody></table><h3 id="1-2案例描述"><a href="#1-2案例描述" class="headerlink" title="1.2案例描述"></a>1.2案例描述</h3><p>​        设计一个小程序，分别利用style和class属性设置字体样式，在index.wxss中定义样式类。所有的文字都包含在一个边框内，边框内上方有标题文字，边框和标题样式利用class属性来设置，在app.wxss中定义样式类。</p><h3 id="1-3实现效果"><a href="#1-3实现效果" class="headerlink" title="1.3实现效果"></a>1.3实现效果</h3><p><img src="https://img-blog.csdnimg.cn/8b306273cc744ac6abd33e33dbc6cdb0.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_10,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="01"></p><p>​        边框样式和标题样式是在app.wxss文件中定义的样式类，在index.wxml文件中利用class引用。标题下面的、双虚线上面的文字样式是在index.wxml中直接利用style来设置的，设置的字体的样式为：sans-serif、30像素。虚线下面的样式是通过index.wxss文件中定义，在index.wxml文件中利用class来引用的，设置的字体的样式为：Cursive、25像素、倾斜、加粗。</p><h3 id="1-4案例实现"><a href="#1-4案例实现" class="headerlink" title="1.4案例实现"></a>1.4案例实现</h3><h4 id="1-4-1编写index-wxml文件代码"><a href="#1-4-1编写index-wxml文件代码" class="headerlink" title="1.4.1编写index.wxml文件代码"></a>1.4.1编写index.wxml文件代码</h4><p>​        style是直接在标签内部进行设置，而class要现在wxss文件中定义样式类，再在wxml文件中通过class属性引用。</p><pre><code>&lt;!--index.wxml--&gt;&lt;view class=&#39;box&#39;&gt; &lt;view class=&quot;title&quot;&gt;字体样式设置&lt;/view&gt; &lt;view style=&#39;font-family:&quot;sans-serif&quot;;font-size:30px;&#39;&gt;  &lt;view&gt;利用style设置字体样式：&lt;/view&gt;  &lt;view&gt;字体：sans-serif，30像素&lt;/view&gt; &lt;/view&gt; ============================ &lt;view class=&quot;fontStyle&quot;&gt;  &lt;view&gt;利用class设置字体样式：&lt;/view&gt;  &lt;view&gt;字体：Cursive，25像素，倾斜，加粗&lt;/view&gt; &lt;/view&gt;&lt;/view&gt;</code></pre><h4 id="1-4-2编写app-wxss文件代码"><a href="#1-4-2编写app-wxss文件代码" class="headerlink" title="1.4.2编写app.wxss文件代码"></a>1.4.2编写app.wxss文件代码</h4><p>​        .box和.title两种全局样式类，以后案例都将使用这两种样式。</p><pre><code>/** app.wxss **/.box&#123; &lt;!--定义用于设置边框样式--&gt; margin: 20rpx;                             //外边距 padding: 20rpx;                            //内边距 border: 1px solid silver;                  //边框1px，实线，银灰色&#125;.title&#123;&lt;!--定义用于设置标题样式--&gt;  font-size: 25px;                           //字体大小为25px text-align: center;                        //文本水平对齐方式为居中 margin-bottom: 15px;                       //外边距为15px color: brown;                              //设置颜色&#125;</code></pre><h4 id="1-4-3编写index-wxss文件代码"><a href="#1-4-3编写index-wxss文件代码" class="headerlink" title="1.4.3编写index.wxss文件代码"></a>1.4.3编写index.wxss文件代码</h4><p>​       代码中定义.fontStyle样式类，该样式将在index.wxml文件中被使用。</p><pre><code>/** index.wxss **/.fontStyle &#123;&lt;!--定义样式类--&gt; font-size: 25px;                          //设置字体大小 font-family: cursive;                     //设置字体类型 font-style: italic;                       //设置字体倾斜 font-weight: bold;                        //设置字体加粗&#125;</code></pre><h2 id="2-文本样式设置"><a href="#2-文本样式设置" class="headerlink" title="2.文本样式设置"></a>2.文本样式设置</h2><h3 id="2-1知识点"><a href="#2-1知识点" class="headerlink" title="2.1知识点"></a>2.1知识点</h3><p>​        文本属性可定义文本的外观。通过文本属性可以设置文本颜色，字符间距，文本对齐，文本装饰，文本缩进，等等。</p><table><thead><tr><th align="center">属性</th><th align="center">含义</th><th align="left">属性值举例</th></tr></thead><tbody><tr><td align="center">color</td><td align="center">文本颜色</td><td align="left">red,#0000ff,#0f0,rgb(red,green,blue),reba(red,green,blue,alpha)</td></tr><tr><td align="center">text-align</td><td align="center">文本对齐</td><td align="left">left&#x2F;right&#x2F;center&#x2F;justify</td></tr><tr><td align="center">text-indent</td><td align="center">文本缩进</td><td align="left">left：固定尺寸的缩进，默认值为0，可以是负数和正数；%：定义基于父元素宽度的百分比的缩进；inherit：继承父元素text-indent属性的值</td></tr><tr><td align="center">letter-spacing</td><td align="center">字符间距</td><td align="left">normal&#x2F;&lt;长度值&gt;</td></tr><tr><td align="center">word-spacing</td><td align="center">单词间距</td><td align="left">normal&#x2F;&lt;长度值&gt;</td></tr><tr><td align="center">word-space</td><td align="center">文档中的空白处</td><td align="left">normal、nowrap、pre、pre-line、pre-warp</td></tr><tr><td align="center">text-decoration</td><td align="center">文本装饰</td><td align="left">none、overline、line-through、underline</td></tr><tr><td align="center">text-decoration-color</td><td align="center">文本装饰颜色</td><td align="left">red,#0000ff,#0f0,rgb(red,green,blue),reba(red,green,blue,alpha)</td></tr></tbody></table><h3 id="2-2案例描述"><a href="#2-2案例描述" class="headerlink" title="2.2案例描述"></a>2.2案例描述</h3><p>​        设计一个小程序，利用class属性设置文本样式，包括：设置文本颜色，字符间距，文本对齐，文本装饰，文本缩进，等等。</p><h3 id="2-3实现效果"><a href="#2-3实现效果" class="headerlink" title="2.3实现效果"></a>2.3实现效果</h3><p><img src="https://img-blog.csdnimg.cn/2aba7736c6eb43c5a6458f88e3e43100.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="02"></p><h3 id="2-4案例实现"><a href="#2-4案例实现" class="headerlink" title="2.4案例实现"></a>2.4案例实现</h3><h4 id="2-4-1编写index-wxml文件代码"><a href="#2-4-1编写index-wxml文件代码" class="headerlink" title="2.4.1编写index.wxml文件代码"></a>2.4.1编写index.wxml文件代码</h4><pre><code>&lt;view class=&quot;box&quot;&gt;  &lt;view class=&quot;title&quot;&gt;文本样式设置&lt;/view&gt;  &lt;view class=&quot;textStyle01&quot;&gt;    文本属性可定义文本的外观。通过设置文本属性，您可以改变文本的颜色、字符间距，对齐文本，装饰文本，对文本进行缩进，等等。  &lt;/view&gt;  ============================  &lt;view class=&quot;textStyle02&quot;&gt;     North China University of Technology(NCUT) is located in the western part of Beijing, whitch is a municipal university founded in 1946.  &lt;/view&gt;&lt;/view&gt;</code></pre><h4 id="2-4-2编写index-wxss文件代码"><a href="#2-4-2编写index-wxss文件代码" class="headerlink" title="2.4.2编写index.wxss文件代码"></a>2.4.2编写index.wxss文件代码</h4><pre><code>.textStyle01&#123;  color: red;  letter-spacing: 10px;  text-align: left;  text-indent: 50px;                  /*首行缩进*/  text-decoration: underline;         /*文本修饰样式：下划线*/  text-decoration-color: #00f;        /*修饰样式颜色：下划线颜色*/  line-height: 30px;                  /*行间距*/  white-space: normal;&#125;.textStyle02&#123;  text-align: justify;               /*文本对齐：两端对齐*/  word-spacing: 20px;                /*字间距：20px*/  text-transform: uppercase;         /*文本中的字母转换为其他形式：大写*/  white-space: pre-wrap;             /*文档中的空白处保留空白、缩进和正常换行*/&#125;</code></pre><h2 id="3-图片与声音"><a href="#3-图片与声音" class="headerlink" title="3.图片与声音"></a>3.图片与声音</h2><h3 id="3-1知识点"><a href="#3-1知识点" class="headerlink" title="3.1知识点"></a>3.1知识点</h3><p>​        本案例主要涉及image图片组建的使用方法，音频的创建和使用方法，以及数据和事件绑定的实现方法。</p><h4 id="3-1-1image组件"><a href="#3-1-1image组件" class="headerlink" title="3.1.1image组件"></a>3.1.1image组件</h4><p>​        支持JPG，PNG，SVG格式，用src属性指定图片的路径。</p><h4 id="3-1-2使用音频"><a href="#3-1-2使用音频" class="headerlink" title="3.1.2使用音频"></a>3.1.2使用音频</h4><p>​        首先要利用API函数wx.createInnerAudioContext()创建音频上下文，然后设置该上下文的源文件src，并利用play()函数播放音频。</p><h4 id="3-1-3数据绑定"><a href="#3-1-3数据绑定" class="headerlink" title="3.1.3数据绑定"></a>3.1.3数据绑定</h4><p>​        WXML文件中动态函数通过与JS文件中的数据进行绑定，这样JS中的数据就可以传给WXML文件。这种传递是单向的。</p><h4 id="3-1-4事件绑定"><a href="#3-1-4事件绑定" class="headerlink" title="3.1.4事件绑定"></a>3.1.4事件绑定</h4><p>​        在WXML文件组件标签内利用“bind…&#x3D;函数名”绑定组件事件与函数，并在JS文件中定义该事件函数。</p><h3 id="3-2案例描述"><a href="#3-2案例描述" class="headerlink" title="3.2案例描述"></a>3.2案例描述</h3><p>​        设计一个小程序，小程序运行后显示一张猫图，点击图片后会发出猫叫的声音。</p><h3 id="3-3实现效果"><a href="#3-3实现效果" class="headerlink" title="3.3实现效果"></a>3.3实现效果</h3><p><img src="https://img-blog.csdnimg.cn/5c305c3d6054458f9a41310478d74f80.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_8,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="03"></p><h3 id="3-4案例实现"><a href="#3-4案例实现" class="headerlink" title="3.4案例实现"></a>3.4案例实现</h3><h4 id="3-4-1准备图片和音频文件"><a href="#3-4-1准备图片和音频文件" class="headerlink" title="3.4.1准备图片和音频文件"></a>3.4.1准备图片和音频文件</h4><p>​        在项目根目录中创建images和audios文件夹，并把kitty.ipg图片文件和meow.mp3音频文件分别复制到images和audios文件夹中(注：audios文件夹必须在根目录下)。</p><h4 id="3-4-2编写index-wxml文件代码。"><a href="#3-4-2编写index-wxml文件代码。" class="headerlink" title="3.4.2编写index.wxml文件代码。"></a>3.4.2编写index.wxml文件代码。</h4><p>​        代码中主要使用了image组件，并在组件中进行了数据绑定和事件绑定。image组件用来设置图片，其中src属性用来指定图片的路径，本案例绑定了属性值imgSrc，该值在index.js文件中的data中进行了初始化；bindtap属性绑定了点击图片函数tapCat，该函数在index.js文件中进行了定义。</p><pre><code>&lt;view class=&quot;box&quot;&gt;  &lt;view class=&quot;title&quot;&gt;图片和声音&lt;/view&gt;  &lt;view style=&quot;text-align:center;&quot;&gt;    &lt;image src=&#39;&#123;&#123;imgSrc&#125;&#125;&#39; bindtap=&#39;tapCat&#39;&gt;&lt;/image&gt;  &lt;/view&gt;&lt;/view&gt;</code></pre><h4 id="3-4-3编写index-js文件代码。"><a href="#3-4-3编写index-js文件代码。" class="headerlink" title="3.4.3编写index.js文件代码。"></a>3.4.3编写index.js文件代码。</h4><p>​        代码在data中给出了图片路径，并定义了点击图片事件处理函数tapCat。</p><pre><code>// index.jsPage(&#123;  data:&#123;    imgSrc:&#39;/images/kitty.jpg&#39;                //图片源文件  &#125;,  tapCat:function()&#123;    let audio=wx.createInnerAudioContext()    //创建音频上下文    audio.src=&#39;/audios/meow.mp3&#39;              //设置音频源文件，需要放在根目录下    audio.play()                              //播放音频  &#125;&#125;)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;小程序编程基础（一）&quot;&gt;&lt;a href=&quot;#小程序编程基础（一）&quot; class=&quot;headerlink&quot; title=&quot;小程序编程基础（一）&quot;&gt;&lt;/a&gt;小程序编程基础（一）&lt;/h2&gt;&lt;h2 id=&quot;1-字体样式设置&quot;&gt;&lt;a href=&quot;#1-字体样式设置&quot; cla</summary>
      
    
    
    
    
    <category term="微信小程序" scheme="http://sang63.github.io/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>双核心出口三层结构园区网配置（完整版）</title>
    <link href="http://sang63.github.io/2021/11/25/%E5%8F%8C%E6%A0%B8%E5%BF%83%E5%87%BA%E5%8F%A3%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84%E5%9B%AD%E5%8C%BA%E7%BD%91%E9%85%8D%E7%BD%AE%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89/"/>
    <id>http://sang63.github.io/2021/11/25/%E5%8F%8C%E6%A0%B8%E5%BF%83%E5%87%BA%E5%8F%A3%E4%B8%89%E5%B1%82%E7%BB%93%E6%9E%84%E5%9B%AD%E5%8C%BA%E7%BD%91%E9%85%8D%E7%BD%AE%EF%BC%88%E5%AE%8C%E6%95%B4%E7%89%88%EF%BC%89/</id>
    <published>2021-11-25T03:00:21.000Z</published>
    <updated>2021-11-25T09:42:02.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置双核心三层结构双路由双出口园区网："><a href="#配置双核心三层结构双路由双出口园区网：" class="headerlink" title="配置双核心三层结构双路由双出口园区网："></a><strong>配置双核心三层结构双路由双出口园区网</strong>：</h3><h4 id="环境要求："><a href="#环境要求：" class="headerlink" title="环境要求："></a><strong>环境要求：</strong></h4><p>1、安装win7、win10或winsrv的pc机一台</p><p>2、cisco Packet Tracer7.3以上模拟器</p><h4 id="任务一-在模拟器上配置网络拓扑，分配IP地址"><a href="#任务一-在模拟器上配置网络拓扑，分配IP地址" class="headerlink" title="任务一:在模拟器上配置网络拓扑，分配IP地址"></a><strong>任务一:在模拟器上配置网络拓扑，分配IP地址</strong></h4><p><img src="https://img-blog.csdnimg.cn/bcc47a7826ef4b368cc17248a6145e4c.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="01"></p><table><thead><tr><th><strong>设备名</strong></th><th><strong>端口&#x2F;接口</strong></th><th><strong>IP地址</strong></th><th><strong>掩码长度</strong></th><th><strong>网关</strong></th></tr></thead><tbody><tr><td>PC11.2</td><td>Fa0</td><td>172.16.11.2</td><td>24</td><td>172.16.11.1</td></tr><tr><td>PC12.2</td><td>Fa0</td><td>172.16.12.2</td><td>24</td><td>172.16.12.1</td></tr><tr><td>PC21.2</td><td>Fa0</td><td>172.16.21.2</td><td>24</td><td>172.16.21.1</td></tr><tr><td>PC22.2</td><td>Fa0</td><td>172.16.22.2</td><td>24</td><td>172.16.22.1</td></tr><tr><td>HTTP</td><td>Fa0</td><td>172.16.100.2</td><td>24</td><td>172.16.100.1</td></tr><tr><td>DNS</td><td>Fa0</td><td>172.16.100.3</td><td>24</td><td>172.16.100.1</td></tr><tr><td>InterSrv</td><td>Fa0</td><td>7.1.1.2</td><td>24</td><td>7.1.1.1</td></tr><tr><td>InterDNS</td><td>Fa0</td><td>8.8.8.8</td><td>24</td><td>8.8.8.1</td></tr><tr><td>PC192</td><td>Fa0</td><td>192.168.1.2</td><td>24</td><td>192.168.1.1</td></tr><tr><td>B1DS1</td><td>vlan11</td><td>172.16.11.253</td><td>24</td><td>-</td></tr><tr><td>B1DS1</td><td>vlan12</td><td>172.16.12.253</td><td>24</td><td>-</td></tr><tr><td>B1DS2</td><td>vlan11</td><td>172.16.11.254</td><td>24</td><td>-</td></tr><tr><td>B1DS2</td><td>vlan12</td><td>172.16.12.254</td><td>24</td><td>-</td></tr><tr><td>B2DS1</td><td>vlan21</td><td>172.16.21.253</td><td>24</td><td>-</td></tr><tr><td>B2DS1</td><td>vlan22</td><td>172.16.22.253</td><td>24</td><td>-</td></tr><tr><td>B2DS2</td><td>vlan21</td><td>172.16.21.253</td><td>24</td><td>-</td></tr><tr><td>B2DS2</td><td>vlan22</td><td>172.16.22.253</td><td>24</td><td>-</td></tr><tr><td>S1AS1</td><td>vlan100</td><td>172.16.100.1</td><td>24</td><td>-</td></tr><tr><td>到CS1的接口</td><td>路由接口</td><td>172.16.1.0</td><td>24</td><td></td></tr><tr><td>到CS2的接口</td><td>路由接口</td><td>172.16.2.0</td><td>24</td><td></td></tr><tr><td>R1</td><td>F0&#x2F;1</td><td>1.1.1.1</td><td>29</td><td>-</td></tr><tr><td>R2</td><td>F0&#x2F;2</td><td>2.1.1.1</td><td>30</td><td>-</td></tr><tr><td>ISP1-1</td><td>F0&#x2F;0</td><td>1.1.1.2</td><td>29</td><td>-</td></tr><tr><td>ISP1-1</td><td>F0&#x2F;1</td><td>3.0.0.1</td><td>8</td><td>-</td></tr><tr><td>ISP2-1</td><td>F0&#x2F;0</td><td>2.1.1.2</td><td>30</td><td>-</td></tr><tr><td>ISP2-1</td><td>F0&#x2F;1</td><td>4..0.0.1</td><td>8</td><td>-</td></tr><tr><td>ISP1-2</td><td>F0&#x2F;0</td><td>3.0.0.2</td><td>8</td><td>-</td></tr><tr><td>ISP1-2</td><td>F0&#x2F;1</td><td>5.0.0.1</td><td>8</td><td>-</td></tr><tr><td>ISP2-2</td><td>F0&#x2F;0</td><td>4.0.0.2</td><td>8</td><td>-</td></tr><tr><td>ISP2-2</td><td>F0&#x2F;1</td><td>6.0.0.1</td><td>8</td><td>-</td></tr><tr><td>ISP2-2</td><td>F1&#x2F;0</td><td>9.1.1.1</td><td>30</td><td>-</td></tr><tr><td>ISP3</td><td>F0&#x2F;0</td><td>5.0.0.2</td><td>8</td><td>-</td></tr><tr><td>ISP3</td><td>F0&#x2F;1</td><td>6.0.0.2</td><td>8</td><td>-</td></tr><tr><td>ISP3</td><td>F1&#x2F;1</td><td>7.1.1.1</td><td>24</td><td>-</td></tr><tr><td>ISP3</td><td>F1&#x2F;2</td><td>8.8.8.1</td><td>24</td><td>-</td></tr><tr><td>R3</td><td>F0&#x2F;1</td><td>9.1.1.2</td><td>30</td><td>-</td></tr><tr><td>R3</td><td>F0&#x2F;0</td><td>192.168.1.1</td><td>24</td><td>-</td></tr></tbody></table><h4 id="任务二-配置双核心三层结构双路由双出口园区网"><a href="#任务二-配置双核心三层结构双路由双出口园区网" class="headerlink" title="任务二:配置双核心三层结构双路由双出口园区网"></a><strong>任务二:配置双核心三层结构双路由双出口园区网</strong></h4><ol><li><p>配置B2F1AS1、B2F1AS2两台接入层交换机</p><p>a) 创建vlan</p><p>b) 把接口加入vlan</p><p>B2F1AS1:</p><pre><code>Switch(config)#vlan 21Switch(config-vlan)#int f0/1Switch(config-if)#switchport access vlan 21</code></pre><p>B2F1AS2:</p><pre><code>Switch(config)#vlan 22Switch(config-vlan)#int f0/1Switch(config-if)#switchport access vlan 22</code></pre></li><li><p>配置B2DS1、B2DS2汇聚层交换机二层特性</p><p>a) 配置汇聚层交换机之间双链路etherchannel</p><p> i. 设置etherchannel协议为LACP</p><p>ii. 设置etherchannel模式为active</p><p>B2DS1,B2DS2:</p><pre><code>Switch(config)#int range f0/23-24Switch(config-if-range)#channel-protocol lacpSwitch(config-if-range)#channel-group 1 mode active</code></pre><p>b) 配置汇聚层交换机之间双链路为trunk</p><p> i. 进入port-channel接口<br>ii. 配置封装格式dot1q，设置为trunk</p></li></ol><p>B2DS1,B2DS2:</p><pre><code>   Switch(config)#int port-channel 1   Switch(config-if)#switchport trunk encapsulation dot1q    Switch(config-if)#switchport mode trunk </code></pre><p>c) show etherchannel summary检查etherchannel状态</p><p><img src="https://img-blog.csdnimg.cn/e642bab5da5742f88be51a0defda84f6.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="02"></p><p>   d) 配置汇聚层交换机到接入层交换机的链路为trunk</p><p>   B2DS1,B2DS2:</p><pre><code>Switch(config)#int range f0/1-2Switch(config-if-range)#switchport trunk encapsulation dot1q Switch(config-if-range)#switchport mode trunk </code></pre><p>   e) 配置汇聚层交换机STP生成树，根据vlan设定生成树的主根和次主根</p><p>   B2DS1:</p><pre><code>Switch(config)#vlan 21Switch(config-vlan)#vlan 22Switch(config-vlan)#exitSwitch(config)#spanning-tree vlan 21 root primary Switch(config)#spanning-tree vlan 22 root secondary </code></pre><p>   B2DS2:</p><pre><code>Switch(config)#vlan 21Switch(config-vlan)#vlan 22Switch(config-vlan)#exitSwitch(config)#spanning-tree vlan 22 root primary Switch(config)#spanning-tree vlan 21 root secondary </code></pre><p>   f) show spanning-tree检查生成树状态</p><p>   <img src="https://img-blog.csdnimg.cn/img_convert/9e5e4d169bf799815488d8b3d6a36a57.png" alt="03"></p><p>   <img src="https://img-blog.csdnimg.cn/img_convert/a3aaec6d91b56a72a25357317448f4aa.png" alt="04"></p><ol start="3"><li><p>配置B2DS1、B2DS2汇聚层交换机三层特性</p><p>a) 在汇聚层交换机启用三层交换功能</p><p>b) 根据地址列表的要求设定vlan接口的地址</p><p>B2DS1:</p><pre><code>Switch(config)#ip routingSwitch(config)#int vlan 21Switch(config-if)#ip addr 172.16.21.253 255.255.255.0Switch(config-if)#int vlan 22Switch(config-if)#ip addr 172.16.22.253 255.255.255.0</code></pre><p>B2DS2:</p><pre><code>Switch(config)#ip routingSwitch(config)#int vlan 21Switch(config-if)#ip addr 172.16.21.254 255.255.255.0Switch(config-if)#int vlan 22Switch(config-if)#ip addr 172.16.22.254 255.255.255.0</code></pre><p>c) 配置两个交换块的热备份路由</p><p> i. 进入vlan接口<br>ii. 配置备份组的虚拟IP地址</p><p>iii. 配置路由器的优先级和占先权</p></li></ol><p>B2DS1:</p><pre><code>   Switch(config-if)#int vlan 21   Switch(config-if)#standby 21 ip 172.16.21.1   Switch(config-if)#standby 21 preempt    Switch(config-if)#standby 21 priority 200   Switch(config-if)#int vlan 22   Switch(config-if)#standby 22 ip 172.16.22.1</code></pre><p>B2DS2:</p><pre><code>   Switch(config-if)#int vlan 21   Switch(config-if)#standby 21 ip 172.16.21.1   Switch(config-if)#int vlan 22   Switch(config-if)#standby 22 ip 172.16.22.1   Switch(config-if)#standby 22 preempt    Switch(config-if)#standby 22 priority 200</code></pre><p>d) show standby检查HSRP状态</p><p><img src="https://img-blog.csdnimg.cn/4b64b06fac0b4dde80050e93af19fd58.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="05"></p><p><img src="https://img-blog.csdnimg.cn/48f4789489264328b57d1b4daccde9b0.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="06"></p><p>   e)检查连通情况</p><p><img src="https://img-blog.csdnimg.cn/img_convert/5df4f69d3d79b6080d61ce0a6856a843.png" alt="07"></p><ol start="4"><li><p>配置S1AS1和B2DS1、B2DS2上连核心接口地址</p><p>a) 在S1AS1创建vlan100，加入连接服务器的接口</p><pre><code>Switch(config)#vlan 100Switch(config-vlan)#int range f0/3-4Switch(config-if-range)#switchport access vlan 100</code></pre><p>b) 在S1AS1启用三层功能，设置vlan100的接口地址</p><pre><code>Switch(config)#ip routingSwitch(config)#int vlan 100Switch(config-if)#ip addr 172.16.100.1 255.255.255.0</code></pre><p>c) 配置与核心层交换机相连接口的IP地址</p><p>i. 把所有接口设为路由接口</p><p>ii. 设置所有与CS1相连接口的地址为172.16.1.0&#x2F;24</p><p>iii. 设置所有与CS2相连接口的地址为172.16.2.0&#x2F;24</p><p>B1DS1:</p><pre><code>Switch(config)#int f0/3Switch(config-if)#ip addr 172.16.1.1 255.255.255.0Switch(config-if)#int f0/4Switch(config-if)#ip addr 172.16.2.1 255.255.255.0</code></pre><p>B1DS2:</p><pre><code>Switch(config)#int f0/3Switch(config-if)#ip addr 172.16.1.2 255.255.255.0Switch(config-if)#int f0/4Switch(config-if)#ip addr 172.16.2.2 255.255.255.0</code></pre><p>B2DS1:</p><pre><code>Switch(config)#int f0/4Switch(config-if)#no switchport Switch(config-if)#ip addr 172.16.1.3 255.255.255.0Switch(config-if)#int f0/3Switch(config-if)#no switchport Switch(config-if)#ip addr 172.16.2.3 255.255.255.0</code></pre><p>B2DS2:</p><pre><code>Switch(config)#int f0/3Switch(config-if)#no switchSwitch(config-if)#ip addr 172.16.1.4 255.255.255.0Switch(config-if)#int f0/4Switch(config-if)#no switchSwitch(config-if)#ip addr 172.16.2.4 255.255.255.0</code></pre><p>S1AS1:</p><pre><code>Switch(config)#int f0/1Switch(config-if)#no switchportSwitch(config-if)#ip addr 172.16.1.5 255.255.255.0Switch(config-if)#int f0/2Switch(config-if)#no switchportSwitch(config-if)#ip addr 172.16.2.5 255.255.255.0</code></pre><p>R1:</p><pre><code>Router(config)#int f0/0Router(config-if)#ip addr 172.16.1.6 255.255.255.0Router(config-if)#int f0/1Router(config-if)#ip addr 172.16.2.6 255.255.255.0</code></pre><p>R2:</p><pre><code>Router(config)#int f0/0Router(config-if)#ip addr 172.16.1.7 255.255.255.0Router(config-if)#int f0/1Router(config-if)#ip addr 172.16.2.7 255.255.255.0</code></pre></li><li><p>配置园区网OSPF动态路由协议</p><p>a) 在与核心直接相连的三层交换机和路由器上启用OSPF协议</p><p>b) 宣告自己的直连网络，设定区域为area0</p><p>B1DS1:</p><pre><code>Switch(config)#route ospf 1Switch(config-router)#network 172.16.11.0 0.0.0.255 area 0Switch(config-router)#network 172.16.12.0 0.0.0.255 area 0Switch(config-router)#network 172.16.1.0 0.0.0.255 area 0Switch(config-router)#network 172.16.2.0 0.0.0.255 area 0</code></pre><p>B1DS2:</p><pre><code>Switch(config)#route ospf 1Switch(config-router)#network 172.16.11.0 0.0.0.255 area 0Switch(config-router)#network 172.16.12.0 0.0.0.255 area 0Switch(config-router)#network 172.16.1.0 0.0.0.255 area 0Switch(config-router)#network 172.16.2.0 0.0.0.255 area 0</code></pre><p>B2DS1:</p><pre><code>Switch(config)#route ospf 1Switch(config-router)#network 172.16.21.0 0.0.0.255 area 0Switch(config-router)#network 172.16.22.0 0.0.0.255 area 0Switch(config-router)#network 172.16.1.0 0.0.0.255 area 0Switch(config-router)#network 172.16.2.0 0.0.0.255 area 0</code></pre><p>B2DS2:</p><pre><code>Switch(config)#route ospf 1Switch(config-router)#network 172.16.21.0 0.0.0.255 area 0Switch(config-router)#network 172.16.22.0 0.0.0.255 area 0Switch(config-router)#network 172.16.1.0 0.0.0.255 area 0Switch(config-router)#network 172.16.2.0 0.0.0.255 area 0</code></pre><p>S1AS1:</p><pre><code>Switch(config)#route ospf 1Switch(config-router)#network 172.16.100.0 0.0.0.255 area 0Switch(config-router)#network 172.16.1.0 0.0.0.255 area 0Switch(config-router)#network 172.16.2.0 0.0.0.255 area 0</code></pre><p>R1:</p><pre><code>Router(config)#route ospf 1Router(config-router)#network 172.16.1.0 0.0.0.255 area 0Router(config-router)#network 172.16.2.0 0.0.0.255 area 0Router(config-router)#default-information originate</code></pre><p>R2:</p><pre><code>Router(config)#route ospf 1Router(config-router)#network 172.16.1.0 0.0.0.255 area 0Router(config-router)#network 172.16.2.0 0.0.0.255 area 0Router(config-router)#default-information originate</code></pre><p>c) 在出口路由器检查路由表</p><p>R1,R2:</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f2d7ff8c22b3a5a5e0e8e8f86a66ae11.png" alt="08"></p><p>d) 在园区网内检查连通性–pc22.1ping http服务器</p><p><img src="https://img-blog.csdnimg.cn/img_convert/f358e01b052f6c266c93941dee4223e0.png" alt="09"></p></li><li><p>配置互联网ISP动态路由协议</p><p>配置方案：自治系统内采用OSPF，自治系统间使用BGP</p><p>a) 在自治区域内启用单区域OSPF并宣告网络</p><p>ISP1-1:</p><pre><code>Router(config)#route ospf 1Router(config-router)#network 1.1.1.0 0.0.0.7 area 0Router(config-router)#network 3.0.0.0 0.255.255.255 area 0</code></pre><p>ISP1-2:</p><pre><code>Router(config)#route ospf 1Router(config-router)#network 3.0.0.0 0.255.255.255 area 0Router(config-router)#network 5.0.0.0 0.255.255.255 area 0</code></pre><p>ISP2-1:</p><pre><code>Router(config)#route ospf 1Router(config-router)#network 2.1.1.0 0.0.0.3 area 0Router(config-router)#network 4.0.0.0 0.255.255.255 area 0</code></pre><p>ISP2-2:</p><pre><code>Router(config)#route ospf 1Router(config-router)#network 4.0.0.0 0.255.255.255 area 0Router(config-router)#network 6.0.0.0 0.255.255.255 area 0Router(config-router)#network 9.1.1.0 0.0.0.3 area 0</code></pre><p>b)在ISP1-2和ISP2-2上启用BGP，配置邻居为ISP3；</p><p>ISP1-2:</p><pre><code>Router(config)#route bgp 100Router(config-router)#neighbor 5.0.0.2 remote-as 300</code></pre><p>ISP2-2:</p><pre><code>Router(config)#route bgp 200Router(config-router)#neighbor 6.0.0.2 remote-as 300</code></pre><p>ISP3:</p><pre><code>Router(config)#route bgp 300Router(config-router)#neighbor 5.0.0.1 remote-as 100Router(config-router)#neighbor 6.0.0.1 remote-as 200</code></pre><p>c) 在ISP1-2和ISP2-2上启用BGP，配置邻居为ISP3；把OSPF路由动态注入到BGP，把BGP路由再分配到OSPF</p><p>ISP1-2:</p><pre><code>Router(config)#route bgp 100Router(config-router)#redistribute ospf 1</code></pre><p>ISP2-2:</p><pre><code>Router(config)#route bgp 200Router(config-router)#redistribute ospf 1</code></pre><p>ISP3:</p><pre><code>Router(config)#route bgp 300Router(config-router)#network 7.1.1.0 mask 255.255.255.0Router(config-router)#network 8.8.8.0 mask 255.255.255.0</code></pre><p>注入BGP之后再分配到OSPF(顺序不能和上面的颠倒)</p><p>ISP1-2:</p><pre><code>Router(config)#route ospf 1Router(config-router)#redistribute bgp 100 subnets </code></pre><p>ISP2-2:</p><pre><code>Router(config)#route ospf 1Router(config-router)#redistribute bgp 200 subnets </code></pre><p>e) 在ISP1-1和ISP2-1上查看路由表</p></li></ol><p>  <img src="https://img-blog.csdnimg.cn/e2e18d21d50a4044893e0e22d1d73748.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="10"><br><img src="https://img-blog.csdnimg.cn/ad509ccf2b7b49388ada1a82874d68be.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_15,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="11"></p><ol start="7"><li><p>配置园区网出口路由器R1、R2的缺省路由与地址转换</p><p>a) 在路由器R1、R2配置缺省路由指向ISP</p><p>R1:</p><pre><code>Router(config)#ip route 0.0.0.0 0.0.0.0 1.1.1.2</code></pre><p>R2:</p><pre><code>Router(config)#ip route 0.0.0.0 0.0.0.0 2.1.1.2</code></pre><p>b) 把缺省路由再分配到路由器R1、R2的OSPF协议中</p><pre><code>Router(config-router)#default-information originate //宣告ospf时已执行，可略过</code></pre><p>c) 在路由器R1、R2配置地址转换，使得内网能够访问互联网</p><p>R1：</p><pre><code>Router(config)#access-list 1 permit 172.16.0.0 0.0.255.255Router(config)#ip nat inside source list 1 interface f1/0 overload Router(config)#int f1/0Router(config-if)#ip nat outsideRouter(config-if)#int f0/0Router(config-if)#ip nat insideRouter(config-if)#int f0/1Router(config-if)#ip nat inside</code></pre><p>R2：</p><pre><code>Router(config)#access-list 1 permit 172.16.0.0 0.0.255.255Router(config)#ip nat inside source list 1 interface f1/0 overload Router(config)#int f1/0Router(config-if)#ip nat outsideRouter(config-if)#int f0/0Router(config-if)#ip nat insideRouter(config-if)#int f0/1Router(config-if)#ip nat inside</code></pre><p>d) 在路由器R1、R2配置端口映射，使得外网能够访问内网http服务</p><p>R1：</p><pre><code>Router(config)#ip nat inside source static tcp 172.16.100.2 80 1.1.1.1 80</code></pre><p>R2：</p><pre><code>Router(config)#ip nat inside source static tcp 172.16.100.2 80 2.1.1.1 80</code></pre><p>e)检测pc21.2能否访问InterSrv7.1.1.2，</p><p><img src="https://img-blog.csdnimg.cn/a6d9ec16d0ab454d9be8ffba084fed7e.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="12"></p><p> dwon掉R2的f1&#x2F;0口检验，外网访问内网http服务</p><p><img src="https://img-blog.csdnimg.cn/10ba412a0e8347fcb8aedec5d638c441.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="13"></p></li><li><p>配置R3分公司路由器</p><p>a) 配置缺省路由指向ISP2</p><pre><code>Router(config)#ip route 0.0.0.0 0.0.0.0 9.1.1.1</code></pre><p>b) 配置NAT网络地址转换</p><pre><code>Router(config)#access-list 1 permit 192.168.1.0 0.0.0.255Router(config)#ip nat inside source list 1 interface f1/0 overload Router(config)#int f1/0Router(config-if)#ip nat outsideRouter(config-if)#int f0/0Router(config-if)#ip nat inside</code></pre><p>c) 检查PC192能够访问互联网</p><p><img src="https://img-blog.csdnimg.cn/a4ea8f02f5a641b39578e0518a0b596a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_13,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="14"></p></li><li><p>配置园区网DNS和互联网InterDNS服务器</p><p>a) 在DNS设定<a href="http://www.mydomain.com解析为内网地址/">www.mydomain.com解析为内网地址</a></p><p><img src="https://img-blog.csdnimg.cn/cfa447d5781d43d7a095c5b0a06a2d4d.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_20,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="15"></p><p>b) 在InterDNS设定<a href="http://www.mydomain.com解析为园区网出口地址/">www.mydomain.com解析为园区网出口地址</a></p><p><img src="https://img-blog.csdnimg.cn/08e351233b7448d3a8cd95ad6b94fc72.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="16"></p><p>c) 在PC192配置dns服务器，使用浏览器访问<a href="http://www.mydomain.com/">www.mydomain.com</a></p><p><img src="https://img-blog.csdnimg.cn/0f9abcf2d4004a328a64a422b809aa71.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_18,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="17"></p><p>d) 在PC11.2配置dns服务器，使用浏览器访问<a href="http://www.mydomain.com/">www.mydomain.com</a></p><p><img src="https://img-blog.csdnimg.cn/4bdfc70579a34478a69c50ee2fe8d31c.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_17,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="18"></p></li></ol><h4 id="任务三：检查网络连通性和可靠性"><a href="#任务三：检查网络连通性和可靠性" class="headerlink" title="任务三：检查网络连通性和可靠性"></a><strong>任务三：检查网络连通性和可靠性</strong></h4><ol><li><p>从pc21.2  ping到 inter_srv</p><p><img src="https://img-blog.csdnimg.cn/1ed20ed5c33d44058533d46ff71bba18.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="19"></p></li><li><p>从pc22.2  ping到inter_srv</p><p><img src="https://img-blog.csdnimg.cn/171b3e9cf97a464faa7c18d14371b8bd.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_12,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="20"></p></li><li><p>依次当掉B2DS1、CS1、R1，再检查连通性</p></li></ol><p>  <strong>依旧能连通</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;配置双核心三层结构双路由双出口园区网：&quot;&gt;&lt;a href=&quot;#配置双核心三层结构双路由双出口园区网：&quot; class=&quot;headerlink&quot; title=&quot;配置双核心三层结构双路由双出口园区网：&quot;&gt;&lt;/a&gt;&lt;strong&gt;配置双核心三层结构双路由双出口园区网&lt;/s</summary>
      
    
    
    
    
    <category term="网络集成与设计" scheme="http://sang63.github.io/tags/%E7%BD%91%E7%BB%9C%E9%9B%86%E6%88%90%E4%B8%8E%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>smarty模板的使用（2）</title>
    <link href="http://sang63.github.io/2021/11/18/smarty%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%882%EF%BC%89/"/>
    <id>http://sang63.github.io/2021/11/18/smarty%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%882%EF%BC%89/</id>
    <published>2021-11-18T11:14:53.000Z</published>
    <updated>2021-11-25T03:02:08.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="smarty模板的使用（2）："><a href="#smarty模板的使用（2）：" class="headerlink" title="smarty模板的使用（2）："></a>smarty模板的使用（2）：</h3><h4 id="一-函数"><a href="#一-函数" class="headerlink" title="一.函数"></a>一.函数</h4><p>每一个smarty标签输出一个变量或者调用某种函数.<br>在定界符内 函数（用’{‘包住）和其属性（用界符包住）将被处理和输出.例如:  </p><pre><code>&#123;funcname attr1=&quot;val&quot; attr2=&quot;val&quot;&#125; </code></pre><p>在模板里无论是内建函数还是自定义函数都有相同的语法.<br>内建函数将在smarty内部工作,例如 <a href="language.function.if.html"><strong>{if}</strong> </a>, <a href="language.function.section.html"><strong>{section}</strong> </a>and <a href="language.function.strip.html"><strong>{strip}</strong>  </a>.他们不能被修改.<br>自定义函数通过插件机制起作用,它们是附加函数. 只要你喜欢,可以随意修改.你也可以自行添加.</p><h5 id="1-单选框–html-radios"><a href="#1-单选框–html-radios" class="headerlink" title="1.单选框–html_radios"></a>1.单选框–html_radios</h5><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">是否必须</th><th align="center">缺省值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">string</td><td align="center">No</td><td align="center"><em>radio</em></td><td align="center">单选按钮列表的名称</td></tr><tr><td align="center">values</td><td align="center">array</td><td align="center">Yes, 或指定 options 属性</td><td align="center"><em>n&#x2F;a</em></td><td align="center">包含单选按钮值的数组</td></tr><tr><td align="center">output</td><td align="center">array</td><td align="center">Yes, 或指定 options 属性</td><td align="center"><em>n&#x2F;a</em></td><td align="center">包含单选按钮显示值的数组</td></tr><tr><td align="center">checked</td><td align="center">string</td><td align="center">No</td><td align="center"><em>empty</em></td><td align="center">已选定的元素</td></tr><tr><td align="center">options</td><td align="center">associative array</td><td align="center">Yes, 或指定 values 属性</td><td align="center"><em>n&#x2F;a</em></td><td align="center">包含值和显示的关联数组</td></tr><tr><td align="center">separator</td><td align="center">string</td><td align="center">No</td><td align="center"><em>empty</em></td><td align="center">分隔每个单选按钮的字符串</td></tr></tbody></table><p>自定义函数 html_radios 根据给定的数据创建单选按钮组. 该函数可以指定哪个元素被选定. 要么必须指定 values 和 ouput  属性，要么指定 options 替代. 所有的输出与 XHTML 兼容.</p><p>举例：</p><pre><code>01.php//单选框$smarty -&gt; assign(&#39;sex&#39;,array(&#39;man&#39;,&#39;woman&#39;));$smarty -&gt; assign(&#39;out1&#39;,array(&quot;男&quot;,&quot;女&quot;));$smarty -&gt; assign(&#39;sel1&#39;,&#39;man&#39;);</code></pre><pre><code>01.html&lt;!-- 单选框 --&gt;性别：&#123;html_radios  name=&quot;sex&quot; values=$sex checked=$sel1 output=$out1 &#125;</code></pre><p><img src="https://i.loli.net/2021/11/22/X4AWLEQm5bY3pRM.jpg" alt="单选框"></p><h5 id="2-多选框–html-checkboxes"><a href="#2-多选框–html-checkboxes" class="headerlink" title="2.多选框–html_checkboxes"></a>2.多选框–html_checkboxes</h5><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">是否必须</th><th align="center">缺省值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">name</td><td align="center">string</td><td align="center">No</td><td align="center"><em>checkbox</em></td><td align="center">复选按钮组的名称</td></tr><tr><td align="center">values</td><td align="center">array</td><td align="center">Yes, 或指定 options 属性</td><td align="center"><em>n&#x2F;a</em></td><td align="center">包含复选按钮组值的数组</td></tr><tr><td align="center">output</td><td align="center">array</td><td align="center">Yes, 或指定 options 属性</td><td align="center"><em>n&#x2F;a</em></td><td align="center">包含复选按钮组显示值的数组</td></tr><tr><td align="center">selected</td><td align="center">string&#x2F;array</td><td align="center">No</td><td align="center"><em>empty</em></td><td align="center">已选定的元素或元素数组</td></tr><tr><td align="center">options</td><td align="center">associative array</td><td align="center">Yes,或指定 values 属性</td><td align="center"><em>n&#x2F;a</em></td><td align="center">包含值和显示的关联数组</td></tr><tr><td align="center">separator</td><td align="center">string</td><td align="center">No</td><td align="center"><em>empty</em></td><td align="center">分隔每个复选按钮的字符串</td></tr><tr><td align="center">labels</td><td align="center">boolean</td><td align="center">No</td><td align="center"><em>true</em></td><td align="center">是否为每个复选按钮添加 <label> 标签</td></tr></tbody></table><p>自定义函数 html_checkboxes 根据给定的数据创建复选按钮组. 该函数可以指定哪些元素被选定. 要么必须指定 values 和 ouput  属性，要么指定 options 替代. 所有的输出与 XHTML 兼容.</p><p>举例：</p><pre><code>01.php//复选框$smarty -&gt; assign(&#39;val&#39;,array(1,2,3,4,5));$smarty -&gt; assign(&#39;out&#39;,array(&quot;游泳&quot;,&quot;乒乓球&quot;,&quot;排球&quot;,&quot;羽毛球&quot;,&quot;篮球&quot;));$smarty -&gt; assign(&#39;sel&#39;,5);//默认选择，单一$smarty -&gt; assign(&#39;valout&#39;,array(&#39;a&#39;=&gt;&quot;看书&quot;,&#39;b&#39;=&gt;&quot;玩游戏&quot;,&#39;c&#39;=&gt;&quot;敲代码&quot;));$smarty -&gt; assign(&#39;sel2&#39;,array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;));//默认选择，多选</code></pre><pre><code>01.html&lt;!-- 方法一： --&gt;   &#123;html_checkboxes name=&quot;hobby&quot; values=$val output=$out selected=$sel &#125;&lt;br /&gt;&lt;!-- 方法二 --&gt;   &#123;html_checkboxes name=&quot;hobby&quot; options=$valout checked=$sel2 separator=&quot;&lt;br /&gt;&quot;&#125;</code></pre><p><img src="https://i.loli.net/2021/11/22/bpaHzLfTiQyNr4R.jpg"></p><h5 id="3-下拉列表–html-options"><a href="#3-下拉列表–html-options" class="headerlink" title="3.下拉列表–html_options"></a>3.下拉列表–html_options</h5><table><thead><tr><th align="center">属性</th><th align="center">类型</th><th align="center">是否必须</th><th align="center">缺省值</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">values</td><td align="center">array</td><td align="center">Yes, unless using options attribute</td><td align="center"><em>n&#x2F;a</em></td><td align="center">包含下拉列表各元素值的数组</td></tr><tr><td align="center">output</td><td align="center">array</td><td align="center">Yes, unless using options attribute</td><td align="center"><em>n&#x2F;a</em></td><td align="center">包含下拉列表各元素显示值的数组</td></tr><tr><td align="center">selected</td><td align="center">string&#x2F;array</td><td align="center">No</td><td align="center"><em>empty</em></td><td align="center">已选定的元素或元素数组</td></tr><tr><td align="center">options</td><td align="center">associative array</td><td align="center">Yes, unless using values and output</td><td align="center"><em>n&#x2F;a</em></td><td align="center">包含值和显示的关联数组</td></tr><tr><td align="center">name</td><td align="center">string</td><td align="center">No</td><td align="center"><em>empty</em></td><td align="center">下拉菜单的名称</td></tr></tbody></table><p>自定义函数 html_options 根据给定的数据创建选项组. 该函数可以指定哪些元素被选定. 要么必须指定 values 和 ouput  属性，要么指定 options 替代. </p><p>如果给定值是数组，将作为 OPTGROUP 处理，且支持递归. 所有的输出与 XHTML 兼容. </p><p>如果指定了可选属性 <em>name</em>，该选项列表将将被置于<select  name="groupname"></select>标签对中. 如果没有指定，那么只产生选项列表.</p><pre><code>01.php//下拉列表$smarty -&gt; assign(&#39;degree&#39;,array(0=&gt;&quot;请选择&quot;,1=&gt;&quot;幼儿园&quot;,2=&gt;&quot;小学&quot;,3=&gt;&quot;中学&quot;,4=&gt;&quot;大学&quot;));$smarty -&gt; assign(&#39;sel3&#39;,0);$smarty -&gt; assign(&#39;sel4&#39;,array(&#39;1&#39;,&#39;3&#39;));</code></pre><pre><code>01.html方法一：&#123;html_options name=&quot;degree&quot; options=$degree selected=$sel3&#125;方法二：&#123;html_options name=&quot;degree&quot; options=$degree selected=$sel4 multipe=&quot;multipe&quot;&#125;</code></pre><p><img src="https://i.loli.net/2021/11/22/z1hjPfuCcKeW9BR.jpg" alt="下拉列表"></p><h5 id="4-下拉日历–html-select-date"><a href="#4-下拉日历–html-select-date" class="headerlink" title="4.下拉日历–html_select_date"></a>4.下拉日历–html_select_date</h5><table><thead><tr><th>属性</th><th>类型</th><th>是否必须</th><th>缺省值</th><th>描述</th></tr></thead><tbody><tr><td>prefix</td><td>string</td><td>No</td><td>Date_</td><td>变量名称前缀</td></tr><tr><td>time</td><td>timestamp&#x2F;YYYY-MM-DD</td><td>No</td><td>UNIX时间戳或年-月-日</td><td>使用时间类型(data&#x2F;time)</td></tr><tr><td>start_year</td><td>string</td><td>No</td><td>年份或与当前年份的相对值</td><td>下拉列表中第一个年份，或与当前年份的相对值(正&#x2F;负 几年)</td></tr><tr><td>end_year</td><td>string</td><td>No</td><td>同start_year</td><td>下拉列表中最后一个年份，或与当前年份的相对值(正&#x2F;负 几年)</td></tr><tr><td>display_days</td><td>boolean</td><td>No</td><td>true</td><td>是否显示天</td></tr><tr><td>display_months</td><td>boolean</td><td>No</td><td>true</td><td>是否显示月</td></tr><tr><td>display_years</td><td>boolean</td><td>No</td><td>true</td><td>是否显示年</td></tr><tr><td>month_format</td><td>string</td><td>No</td><td>%B</td><td>月份的表示方法(strftime)</td></tr><tr><td>day_format</td><td>string</td><td>No</td><td>%02d</td><td>天显示的格式(sprintf)</td></tr><tr><td>day_value_format</td><td>string</td><td>No</td><td>%d</td><td>天的表示方法(sprintf)</td></tr><tr><td>year_as_text</td><td>boolean</td><td>No</td><td>false</td><td>是否以文本方式显示年份</td></tr><tr><td>reverse_years</td><td>boolean</td><td>No</td><td>false</td><td>逆序显示年份</td></tr><tr><td>field_array</td><td>string</td><td>No</td><td>null</td><td>如果指定了名称，选定的区域将以[Day],[Year],[Month]的形式返回给PHP(待考)</td></tr><tr><td>day_size</td><td>string</td><td>No</td><td>null</td><td>如果给定，为标签添加大小属性</td></tr><tr><td>month_size</td><td>string</td><td>No</td><td>null</td><td>如果给定，为标签添加大小属性</td></tr><tr><td>year_size</td><td>string</td><td>No</td><td>null</td><td>如果给定，为标签添加大小属性</td></tr><tr><td>all_extra</td><td>string</td><td>No</td><td>null</td><td>如果给定，为所有标签添加附加属性</td></tr><tr><td>day_extra</td><td>string</td><td>No</td><td>null</td><td>如果给定，为标签添加附加属性</td></tr><tr><td>month_extra</td><td>string</td><td>No</td><td>null</td><td>如果给定，为标签添加附加属性</td></tr><tr><td>year_extra</td><td>string</td><td>No</td><td>null</td><td>如果给定，为标签添加附加属性</td></tr><tr><td>field_order</td><td>string</td><td>No</td><td>MDY</td><td>显示区域的顺序</td></tr><tr><td>field_separator</td><td>string</td><td>No</td><td>\n</td><td>各区域间输出的分隔字符串</td></tr><tr><td>month_value_format</td><td>string</td><td>No</td><td>%m</td><td>月份值的strftime表示方法，默认为 %m</td></tr></tbody></table><p>自定义函数 html_select_date 用于创建日期下拉菜单. 它可以显示任意年月日.</p><pre><code>01.html&#123;html_select_date&#125;</code></pre><p><img src="https://i.loli.net/2021/11/22/ZlXhJk7gS5eDavP.jpg" alt="下拉日历"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;smarty模板的使用（2）：&quot;&gt;&lt;a href=&quot;#smarty模板的使用（2）：&quot; class=&quot;headerlink&quot; title=&quot;smarty模板的使用（2）：&quot;&gt;&lt;/a&gt;smarty模板的使用（2）：&lt;/h3&gt;&lt;h4 id=&quot;一-函数&quot;&gt;&lt;a href</summary>
      
    
    
    
    
    <category term="smarty" scheme="http://sang63.github.io/tags/smarty/"/>
    
  </entry>
  
  <entry>
    <title>smarty模板的使用（1）</title>
    <link href="http://sang63.github.io/2021/11/11/smarty%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%881%EF%BC%89/"/>
    <id>http://sang63.github.io/2021/11/11/smarty%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8%EF%BC%881%EF%BC%89/</id>
    <published>2021-11-11T12:43:57.000Z</published>
    <updated>2021-11-25T03:02:18.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="smarty模板的使用（1）"><a href="#smarty模板的使用（1）" class="headerlink" title="smarty模板的使用（1）:"></a>smarty模板的使用（1）:</h3><h4 id="一-什么是smarty模板？"><a href="#一-什么是smarty模板？" class="headerlink" title="一.什么是smarty模板？"></a>一.什么是smarty模板？</h4><p>Smarty是一个php模板引擎。更准确的说,它分开了逻辑程序和外在的内容,提供了一种易于管理的方法。可以描述为应用程序员和美工扮演了不同的角色,因为在大多数情况下  ,他们不可能是同一个人。</p><p>例如,你正在创建一个用于浏览新闻的网页,新闻标题,标签栏,作者和内容等都是内容要素,他们并不包含应该怎样去呈现。在Smarty的程序里,这些被忽略了。模板设计者们编辑模板,组合使用html标签和模板标签去格式化这些要素的输出(html表格,背景色,字体大小,样式表,等等)。有一天程序员想要改变文章检索的方式(也就是程序逻辑的改变)。这个改变不影响模板设计者,内容仍将准确的输出到模板。同样的,哪天美工吃多了想要完全重做界面,也不会影响到程序逻辑。因此,程序员可以改变逻辑而不需要重新构建模板,模板设计者可以改变模板而不影响到逻辑。</p><h4 id="二-下载使用"><a href="#二-下载使用" class="headerlink" title="二.下载使用"></a>二.下载使用</h4><blockquote><p>注意：Smarty要求web服务器运行php4.0.6和以上版本. </p><p>下载smarty最新版本，由于我们需要用到的模板都存放在.&#x2F;bin&#x2F;Smarty.class.php下，所以，可以将.&#x2F;bin文件夹存放到事先设好的网站根目录下。</p></blockquote><h4 id="三-变量调节器"><a href="#三-变量调节器" class="headerlink" title="三.变量调节器"></a>三.变量调节器</h4><h5 id="1-替换replace"><a href="#1-替换replace" class="headerlink" title="1.替换replace"></a>1.替换replace</h5><p>原理：简单的搜索与替换字符串</p><p>举例：</p><p>在存放.&#x2F;bin的文件夹下创建01.html与01.php文件，输入以下代码</p><pre><code>01.html：&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;    &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;    &lt;title&gt;Smarty&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;h2&gt;Smarty的使用-替换&lt;/h2&gt;    &lt;div&gt;学号：&#123;$id&#125;&lt;/div&gt;    &lt;div&gt;姓名：&#123;$name&#125;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code>01.php&lt;?php//引入模板引擎include &#39;./libs/Smarty.class.php&#39;;$id = &#39;1005&#39;;$name = &#39;shanshan&#39;;//实例化$smarty = new Smarty();$smarty -&gt; assign(&#39;id&#39;,$id);$smarty -&gt; assign(&#39;name&#39;,$name);$smarty -&gt; display(&#39;01.html&#39;);?&gt;</code></pre><p>在浏览器上运行01.php，文件夹内会生成一个新的文件夹template_c，并且显示页面：</p><p><img src="https://img-blog.csdnimg.cn/05fe35307fdf4b139fbc2655cad162b6.jpg#pic_center" alt="1"></p><p>此时，template_c内的文件就是经过模板嵌套后的代码，也是浏览器所显示的部分。</p><p>替换过程（会使用即可，在smarty.class.php中）：</p><pre><code>   //str_replace(&#39;将被替换的文本字串&#39;,&#39;用来替换的文本字串&#39;)；    str_replace(&#39;&#123;&#39;,&#39;&lt;?php echo &#39;);     str_replace(&#39;&#125;&#39;,&#39;; ?&gt; &#39;);  </code></pre><h5 id="2-注释"><a href="#2-注释" class="headerlink" title="2.注释"></a>2.注释</h5><p>模板注释被<em>号包围,例如{</em> this is a comment *}，smarty注释不会在模板文件的最后输出中出现.</p><p>它只是模板内在的注释. </p><h5 id="3-访问数组元素"><a href="#3-访问数组元素" class="headerlink" title="3.访问数组元素"></a>3.访问数组元素</h5><pre><code>   01.html   &lt;h2&gt;smarty模板访问数组元素&#123;*数组名.下标 或者 数组名[下标]*&#125;&lt;/h2&gt; //&#123;* *&#125;表示注释    &lt;div&gt;所在学院：&#123;$dept.0&#125;&lt;/div&gt;    &lt;div&gt;最喜欢的学院：&#123;$dept[1]&#125;&lt;/div&gt;</code></pre><pre><code>01.php$smarty -&gt; assign(&#39;dept&#39;,array(&#39;信息技术学院&#39;,&#39;法学院&#39;,&#39;商学院&#39;));</code></pre><p>在浏览器上运行01.php，得到：</p><p><img src="https://img-blog.csdnimg.cn/8e33e17d58474a698aa6acc0653cb21a.jpg#pic_center" alt="2"></p><h5 id="4-遍历数组"><a href="#4-遍历数组" class="headerlink" title="4.遍历数组"></a>4.遍历数组</h5><pre><code>01.html&lt;h2&gt;smarty遍历数组&#123;*&#123;foreach 数组名 as 变量1 =&gt; 变量名2&#125;&#123;/foreach&#125;*&#125;&lt;/h2&gt;    &lt;div&gt;学院列表：&lt;br/&gt;        &#123;foreach $dept as $a =&gt; $b&#125;            &#123;$a&#125;------&#123;$b&#125; &lt;br /&gt;        &#123;/foreach&#125;    &lt;/div&gt;</code></pre><p>在浏览器上运行01.php，得到：</p><p><img src="https://img-blog.csdnimg.cn/e7dcba4513a045e5933cb35c4ba70969.jpg#pic_center" alt="3"></p><h5 id="5-变量修饰器"><a href="#5-变量修饰器" class="headerlink" title="5.变量修饰器"></a>5.变量修饰器</h5><p>（1）什么是变量修饰器？</p><p>​         变量在输出之前，被其他的函数再处理过滤一下，这个其他函数就被称为“变量修饰器”。</p><p>（2）使用格式</p><ul><li>普通变量输出：{$content};</li><li>变量修饰器：{$content|修饰器名字}，当使用多个修饰器时{$content|修饰器1名字|修饰器2名字|。。。修饰器n名字}。</li></ul><p>​    注意：“|”前后不要加空格</p><pre><code>01.html&lt;h2&gt;修饰器&lt;/h2&gt;    &lt;div&gt;        名字：&#123;$username&#125;&lt;br/&gt;        名字：&#123;$username|lower&#125;&lt;br/&gt;        名字：&#123;$username|upper&#125;&lt;br/&gt;        时间：&#123;$mytime&#125;&lt;br/&gt;        时间：&#123;$mytime|date_format:&quot;%Y-%m-%d  %H:%M:%S&quot;&#125;&lt;br/&gt;        名字：&#123;$username|indent:1:&#39;USA:&#39;&#125;&lt;br/&gt;        名字：&#123;$username|indent:2:&#39;USA:&#39;&#125;&lt;br/&gt;        心情日记：&#123;$note&#125;&lt;br/&gt;        心情日记：&#123;$note|truncate:17&#125;&lt;br/&gt;        心情日记：&#123;$note|truncate:17:&#39;...&#39;:true&#125;&lt;br/&gt;        内容：&#123;$content&#125;&lt;br/&gt;        内容：&#123;$content|replace:&quot;经贸&quot;:&quot;河北经贸大学&quot;&#125;&lt;br/&gt;        名字：&#123;$note|capitalize|truncate:17&#125;&lt;br/&gt;    &lt;/div&gt;</code></pre><pre><code>01.php$smarty -&gt; assign(&#39;mytime&#39;,time());$smarty -&gt; assign(&#39;username&#39;,&#39;shanshan&#39;);$smarty -&gt; assign(&#39;note&#39;,&#39;Today is trursday,I am very happy!&#39;);$smarty -&gt; assign(&#39;content&#39;,&#39;欢迎来到经贸！&#39;);</code></pre><p>在浏览器上运行01.php，得到：</p><p><img src="https://img-blog.csdnimg.cn/8d321e2b76dd471fb8c453acf1debe45.jpg?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_9,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="4"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;smarty模板的使用（1）&quot;&gt;&lt;a href=&quot;#smarty模板的使用（1）&quot; class=&quot;headerlink&quot; title=&quot;smarty模板的使用（1）:&quot;&gt;&lt;/a&gt;smarty模板的使用（1）:&lt;/h3&gt;&lt;h4 id=&quot;一-什么是smarty模板？&quot;</summary>
      
    
    
    
    
    <category term="smarty" scheme="http://sang63.github.io/tags/smarty/"/>
    
  </entry>
  
  <entry>
    <title>Babel对JS-Vue的处理（1）</title>
    <link href="http://sang63.github.io/2021/11/05/Babel%E5%AF%B9JS-Vue%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%881%EF%BC%89/"/>
    <id>http://sang63.github.io/2021/11/05/Babel%E5%AF%B9JS-Vue%E7%9A%84%E5%A4%84%E7%90%86%EF%BC%881%EF%BC%89/</id>
    <published>2021-11-05T10:21:56.000Z</published>
    <updated>2021-11-05T10:24:54.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="为什么需要babel？"><a href="#为什么需要babel？" class="headerlink" title="为什么需要babel？"></a>为什么需要babel？</h3><p>事实上，在开发中我们很少直接去接触babel，但是babel对于前端开发来说，目前是不可缺少的一部分：</p><ul><li>开发中，我们想要使用ES6+的语法，想要使用TypeScript，开发React项目，它们都是离不开Babel的；</li><li>所以，学习Babel对于我们理解代码从编写到线上的转变过程至关重要。</li></ul><blockquote><p><strong>Babel是什么？</strong></p><p>官方给出的解释是，Babel是一个工具链，主要用于旧浏览器或者环境中将ECMAScript 2015+代码转换为向后兼容版本的JavaScript。</p><p>主要包括：语法转换、源代码转换等；</p></blockquote><p>例如：现在有一个数组，数组里有一些数字，将它进行转化，每个元素+1，开发中常用ES6的写法，使用箭头函数，看起来很直观，提高开发效率，但这种代码有些浏览器无法识别，不能解析，会报错。但下面的ES5是比较老的，JS引擎都可以识别，我们不会手动转化，这个时候就用到babel了</p><p><img src="https://img-blog.csdnimg.cn/fedfea83bf66475e8ac667a583f0248d.png#pic_center" alt="01"></p><h3 id="Babel命令行使用"><a href="#Babel命令行使用" class="headerlink" title="Babel命令行使用"></a>Babel命令行使用</h3><p>babel本身可以作为一个独立的工具（和postcss一样），不和webpack等构建工具配置来单独使用。</p><ul><li><p>如果我们希望在命令行尝试使用babel，需要安装如下库：</p><p>@babel&#x2F;core：babel的核心代码，必须安装；<br>@babel&#x2F;cli：可以让我们在命令行使用babel；</p><p><code>npm install @babel/cli @babel/core-D</code></p></li><li><p>使用babel来处理我们的源代码：</p><p>src：是源文件的目录；</p><p>–out-dir：指定要输出的文件夹名；</p><p>–out-file:  指定要输出的文件名。</p></li></ul><p>​       <code>npxbabel src--out-dirdist</code></p><h3 id="插件的使用"><a href="#插件的使用" class="headerlink" title="插件的使用"></a>插件的使用</h3><p>比如我们需要转换箭头函数，那么我们就可以使用箭头函数转换相关的插件：</p><p><code>npm install @babel/plugin-transform-arrow-functions -D</code></p><p><code>npxbabel src--out-dirdist--plugins=@babel/plugin-transform-arrow-functions</code></p><p>查看转换后的结果：我们会发现const 并没有转成var</p><ul><li>这是因为plugin-transform-arrow-functions，并没有提供这样的功能；</li><li>我们需要使用plugin-transform-block-scoping 来完成这样的功能。</li></ul><p><code>npm install @babel/plugin-transform-block-scoping -D </code></p><p><code>npxbabel src--out-dirdist--plugins=@babel/plugin-transform-block-scoping,@babel/plugin-transform-arrow-functions</code></p><h3 id="Babel的预设preset"><a href="#Babel的预设preset" class="headerlink" title="Babel的预设preset"></a>Babel的预设preset</h3><p>但是如果要转换的内容过多，一个个设置是比较麻烦的，我们可以使用预设（preset）：</p><ul><li><p>后面我们再具体来讲预设代表的含义；</p><p>安装@babel&#x2F;preset-env预设：</p><p><code>npm install @babel/preset-env -D</code></p></li><li><p>执行如下命令：</p><p><code>npxbabel src--out-dirdist--presets=@babel/preset-env</code></p></li></ul><h3 id="Babel的底层原理"><a href="#Babel的底层原理" class="headerlink" title="Babel的底层原理"></a>Babel的底层原理</h3><p>babel是如何做到将我们的一段代码（ES6、TypeScript、React）转成另外一段代码（ES5）的呢？</p><ul><li>从一种源代码（原生语言）转换成另一种源代码（目标语言），这是什么的工作呢？</li><li>就是编译器，事实上我们可以将babel看成就是一个编译器。</li><li>Babel编译器的作用就是将我们的源代码，转换成浏览器可以直接识别的另外一段源代码。</li></ul><p>Babel也拥有编译器的工作流程：</p><ul><li><p>解析阶段（Parsing）</p></li><li><p>转换阶段（Transformation）</p></li><li><p>生成阶段（Code Generation）</p></li></ul><p><a href="https://github.com/jamiebuilds/the-super-tiny-compiler">https://github.com/jamiebuilds/the-super-tiny-compiler</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;为什么需要babel？&quot;&gt;&lt;a href=&quot;#为什么需要babel？&quot; class=&quot;headerlink&quot; title=&quot;为什么需要babel？&quot;&gt;&lt;/a&gt;为什么需要babel？&lt;/h3&gt;&lt;p&gt;事实上，在开发中我们很少直接去接触babel，但是babel对于前端</summary>
      
    
    
    
    
    <category term="学习笔记" scheme="http://sang63.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>PHP实现随机发牌功能</title>
    <link href="http://sang63.github.io/2021/10/28/PHP%E5%AE%9E%E7%8E%B0%E9%9A%8F%E6%9C%BA%E5%8F%91%E7%89%8C%E5%8A%9F%E8%83%BD/"/>
    <id>http://sang63.github.io/2021/10/28/PHP%E5%AE%9E%E7%8E%B0%E9%9A%8F%E6%9C%BA%E5%8F%91%E7%89%8C%E5%8A%9F%E8%83%BD/</id>
    <published>2021-10-28T07:07:40.000Z</published>
    <updated>2021-10-28T07:08:44.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、实训目的"><a href="#一、实训目的" class="headerlink" title="一、实训目的"></a><strong>一、实训目的</strong></h3><p>1、掌握数组相关知识。</p><p>2、熟练应用数组遍历。</p><h3 id="二、实训内容"><a href="#二、实训内容" class="headerlink" title="二、实训内容"></a><strong>二、实训内容</strong></h3><p>1、扑克牌是一种家喻户晓的纸牌游戏。一副扑克牌有54张牌，其中52张是正牌，另2张是副牌（大王和小王）。52张正牌又均分为13张一组，并以黑桃、红桃、梅花、方块四种花色表示各组，每组花色的牌包括从1-10（1通常表示为A）以及J、Q、K标示的13张牌，玩法千变万化，多种玩法。</p><p>请通过PHP编程实现扑克牌的随机发牌游戏，通过编程生成52章正牌，然后随机发给A、B、C三位玩家，每人10张牌。</p><h4 id="任务一：生成扑克牌"><a href="#任务一：生成扑克牌" class="headerlink" title="任务一：生成扑克牌"></a>任务一：生成扑克牌</h4><pre><code>&lt;?php// 建立数组保存的牌组池$num = [&#39;A&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;10&#39;, &#39;J&#39;, &#39;Q&#39;, &#39;K&#39;];$icon = [&#39;♥&#39; =&gt; &#39;red&#39;, &#39;♦&#39; =&gt; &#39;red&#39;, &#39;♠&#39; =&gt; &#39;black&#39;, &#39;♣&#39; =&gt; &#39;black&#39;];   // 生成扑克牌组$poker = [];foreach ($icon as $iconkey =&gt; $iconvalue) &#123;        foreach ($num as $value) &#123;            //输出格式：数字+图形            $poker[] = &quot;&lt;font style=&#39;color:$iconvalue&#39;&gt; &#123;$value&#125; &#123;$iconkey&#125;&lt;/font&gt;&quot;;        &#125;    &#125;    echo&quot;生成的扑克牌&quot;;print_r($poker);//打乱前的数组元素echo&#39;&lt;/br&gt;&#39;;//实现“洗牌”功能，将生成的牌打乱顺序shuffle($poker);echo&#39;&lt;/br&gt;&#39;;echo&quot;洗牌后的扑克牌&quot;;print_r($poker);//打印打乱后的数组元素?&gt;</code></pre><p>通过浏览器访问，运行结果如下图所示。</p><p><img src="https://img-blog.csdnimg.cn/218f6b6f0e81471181947d3da9be2741.png#pic_center" alt="01"></p><h4 id="任务二：将扑克牌随机发给A-B-C三位玩家"><a href="#任务二：将扑克牌随机发给A-B-C三位玩家" class="headerlink" title="任务二：将扑克牌随机发给A\B\C三位玩家"></a>任务二：将扑克牌随机发给A\B\C三位玩家</h4><pre><code>&lt;!doctype html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;随机发牌&lt;/title&gt;&lt;style&gt;div&#123;margin:15px 0&#125; //对边框定义font&#123;border:1px solid #ccc;padding:6px 3px;margin-right:10px&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt;玩家A 牌组&lt;/div&gt;&lt;?php //遍历显示A家的牌for ($i = 0; $i &lt; 10; ++$i) &#123;    echo current($poker);    next($poker);&#125; ?&gt;&lt;div&gt;玩家B 牌组&lt;/div&gt;&lt;?php //遍历显示B家的牌for ($i = 0; $i &lt; 10; ++$i) &#123;    echo current($poker);    next($poker);&#125; ?&gt;&lt;div&gt;玩家C 牌组&lt;/div&gt;&lt;?php //遍历显示C家的牌for ($i = 0; $i &lt; 10; ++$i) &#123;    echo current($poker);    next($poker);&#125; ?&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>通过浏览器访问，运行结果如下图所示（每次刷新生成的牌组都不同）。</p><p><img src="https://img-blog.csdnimg.cn/ffbad9b63619483094d66b5b0f72d38a.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5qGR5qGR5ZKM6Zi_5oiY,size_14,color_FFFFFF,t_70,g_se,x_16#pic_center" alt="2"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、实训目的&quot;&gt;&lt;a href=&quot;#一、实训目的&quot; class=&quot;headerlink&quot; title=&quot;一、实训目的&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、实训目的&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;1、掌握数组相关知识。&lt;/p&gt;
&lt;p&gt;2、熟练应用数组遍历。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    
    <category term="PHP" scheme="http://sang63.github.io/tags/PHP/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 ping 域名错误</title>
    <link href="http://sang63.github.io/2021/10/24/Centos7-ping-%E5%9F%9F%E5%90%8D%E9%94%99%E8%AF%AF/"/>
    <id>http://sang63.github.io/2021/10/24/Centos7-ping-%E5%9F%9F%E5%90%8D%E9%94%99%E8%AF%AF/</id>
    <published>2021-10-24T02:29:13.000Z</published>
    <updated>2021-10-24T02:30:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>Centos7 ping <a href="http://www.baidu.com/">www.baidu.com</a> : Name or service not known解决方法（1）<br>文章中出现的问题是我在学习中所遇到的，解决方法也是在自己的揣摩下得以实现，如果我们的问题相同，希望能够帮得到你，如果未能解决你的问题，在此我深表歉意。</p><h1 id="项目场景："><a href="#项目场景：" class="headerlink" title="项目场景："></a>项目场景：</h1><p><font color=#999AAA >虚拟机上网调试过程顺序：<br>  一.ping 网关（网关不通，检查地址）；</br><br>二.ping 外网地址；</br><br>三.ping  域名，例如<a href="http://www.baidu.com/">www.baidu.com</a>(ping 域名不通，ping地址8.8.8.8，若有问题，用route -n检查主机能否上网)。</br></font></p><h1 id="问题描述："><a href="#问题描述：" class="headerlink" title="问题描述："></a>问题描述：</h1><font color=#999AAA >可以ping通网关与外网地址，只有域名ping不通。<pre><code class="c">[root@localhost ~]# ping 192.168.137.34PING 192.168.137.34 (192.168.137.34) 56(84) bytes of data.64 bytes from 192.168.137.34: icmp_seq=1 ttl=64 time=0.021 ms^C--- 192.168.137.34 ping statistics ---3 packets transmitted, 3 received, 0% packet loss, time 2013msrtt min/avg/max/mdev = 0.021/0.035/0.046/0.011 ms[root@localhost ~]# ping 8.8.8.8PING 8.8.8.8 (8.8.8.8) 56(84) bytes of data.64 bytes from 8.8.8.8: icmp_seq=1 ttl=128 time=55.0 ms64 bytes from 8.8.8.8: icmp_seq=2 ttl=128 time=55.4 ms^C--- 8.8.8.8 ping statistics ---4 packets transmitted, 4 received, 0% packet loss, time 3028msrtt min/avg/max/mdev = 55.081/55.275/55.421/0.313 ms[root@localhost ~]# ping www.baidu.comping www.baidu.com : Name or service not known</code></pre><h1 id="原因分析："><a href="#原因分析：" class="headerlink" title="原因分析："></a>原因分析：</h1><p>通常情况下，域名ping不通一般都是DNS域名有问题。<br>首先要判断DNS是否能正常工作</p><pre><code class="c"># ping www.baidu.com    //ping不通# ping 8.8.8.8    //可以ping通//出现这种情况的时候，DNS极有可能处于无法正常工作的状态了。</code></pre><p>接下来就要检查&#x2F;etc&#x2F;resolv.conf文件，发现 # Generated by NetworkManager 。</p><pre><code class="c">[root@localhost ~]# cat /etc/resolv.conf# Generated by NetworkManager</code></pre><h1 id="解决方案："><a href="#解决方案：" class="headerlink" title="解决方案："></a>解决方案：</h1><font color=#999AAA >方案一：使用vim /etc/resolv.conf进行修改，添加<p>nameserver 8.8.8.8   #google dns服务器<br>nameserver 8.8.4.4   #google dns服务器</p><pre><code class="c">[root@localhost ~]# vim /etc/resolv.conf# Generated by NetworkManagernameserver 8.8.8.8nameserver 8.8.4.4   </code></pre><p>检查DNS是否设置成功</p><pre><code class="c"># cat /etc/resolv.conf# Generated by NetworkManagernameserver 8.8.8.8nameserver 8.8.4.4   </code></pre><p>输入service NetworkManager stop，停用 NetworkManager，保存后重启即可。</p><p>方案二:直接在对接口添加DNS信息；编辑&#x2F;etc&#x2F;sysconfig&#x2F;network-scripts&#x2F;ifcfg-eth33，在最下面添加：</p><pre><code class="c">DNS1=8.8.8.8   //google dns服务器DNS2=8.8.4.4   //google dns服务器//保存后重启网络#service network restart</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Centos7 ping &lt;a href=&quot;http://www.baidu.com/&quot;&gt;www.baidu.com&lt;/a&gt; : Name or service not known解决方法（1）&lt;br&gt;文章中出现的问题是我在学习中所遇到的，解决方法也是在自己的揣摩下得以实现</summary>
      
    
    
    
    
    <category term="错误审查" scheme="http://sang63.github.io/tags/%E9%94%99%E8%AF%AF%E5%AE%A1%E6%9F%A5/"/>
    
  </entry>
  
</feed>
